schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

scalar _text

"""
Boolean expression to compare columns of type "_text". All fields are combined with logical 'AND'.
"""
input _text_comparison_exp {
  _eq: _text
  _gt: _text
  _gte: _text
  _in: [_text!]
  _is_null: Boolean
  _lt: _text
  _lte: _text
  _neq: _text
  _nin: [_text!]
}

"""
columns and relationships of "actor"
"""
type actor {
  actor_id: Int!
  first_name: String!
  last_name: String!
  last_update: timestamp!
}

"""
aggregated selection of "actor"
"""
type actor_aggregate {
  aggregate: actor_aggregate_fields
  nodes: [actor!]!
}

"""
aggregate fields of "actor"
"""
type actor_aggregate_fields {
  avg: actor_avg_fields
  count(columns: [actor_select_column!], distinct: Boolean): Int!
  max: actor_max_fields
  min: actor_min_fields
  stddev: actor_stddev_fields
  stddev_pop: actor_stddev_pop_fields
  stddev_samp: actor_stddev_samp_fields
  sum: actor_sum_fields
  var_pop: actor_var_pop_fields
  var_samp: actor_var_samp_fields
  variance: actor_variance_fields
}

"""aggregate avg on columns"""
type actor_avg_fields {
  actor_id: Float
}

"""
Boolean expression to filter rows from the table "actor". All fields are combined with a logical 'AND'.
"""
input actor_bool_exp {
  _and: [actor_bool_exp!]
  _not: actor_bool_exp
  _or: [actor_bool_exp!]
  actor_id: Int_comparison_exp
  first_name: String_comparison_exp
  last_name: String_comparison_exp
  last_update: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "actor"
"""
enum actor_constraint {
  """unique or primary key constraint"""
  actor_pkey
}

"""
input type for incrementing numeric columns in table "actor"
"""
input actor_inc_input {
  actor_id: Int
}

"""
columns and relationships of "actor_info"
"""
type actor_info {
  actor_id: Int
  film_info: String
  first_name: String
  last_name: String
}

"""
aggregated selection of "actor_info"
"""
type actor_info_aggregate {
  aggregate: actor_info_aggregate_fields
  nodes: [actor_info!]!
}

"""
aggregate fields of "actor_info"
"""
type actor_info_aggregate_fields {
  avg: actor_info_avg_fields
  count(columns: [actor_info_select_column!], distinct: Boolean): Int!
  max: actor_info_max_fields
  min: actor_info_min_fields
  stddev: actor_info_stddev_fields
  stddev_pop: actor_info_stddev_pop_fields
  stddev_samp: actor_info_stddev_samp_fields
  sum: actor_info_sum_fields
  var_pop: actor_info_var_pop_fields
  var_samp: actor_info_var_samp_fields
  variance: actor_info_variance_fields
}

"""aggregate avg on columns"""
type actor_info_avg_fields {
  actor_id: Float
}

"""
Boolean expression to filter rows from the table "actor_info". All fields are combined with a logical 'AND'.
"""
input actor_info_bool_exp {
  _and: [actor_info_bool_exp!]
  _not: actor_info_bool_exp
  _or: [actor_info_bool_exp!]
  actor_id: Int_comparison_exp
  film_info: String_comparison_exp
  first_name: String_comparison_exp
  last_name: String_comparison_exp
}

"""aggregate max on columns"""
type actor_info_max_fields {
  actor_id: Int
  film_info: String
  first_name: String
  last_name: String
}

"""aggregate min on columns"""
type actor_info_min_fields {
  actor_id: Int
  film_info: String
  first_name: String
  last_name: String
}

"""Ordering options when selecting data from "actor_info"."""
input actor_info_order_by {
  actor_id: order_by
  film_info: order_by
  first_name: order_by
  last_name: order_by
}

"""
select columns of table "actor_info"
"""
enum actor_info_select_column {
  """column name"""
  actor_id

  """column name"""
  film_info

  """column name"""
  first_name

  """column name"""
  last_name
}

"""aggregate stddev on columns"""
type actor_info_stddev_fields {
  actor_id: Float
}

"""aggregate stddev_pop on columns"""
type actor_info_stddev_pop_fields {
  actor_id: Float
}

"""aggregate stddev_samp on columns"""
type actor_info_stddev_samp_fields {
  actor_id: Float
}

"""aggregate sum on columns"""
type actor_info_sum_fields {
  actor_id: Int
}

"""aggregate var_pop on columns"""
type actor_info_var_pop_fields {
  actor_id: Float
}

"""aggregate var_samp on columns"""
type actor_info_var_samp_fields {
  actor_id: Float
}

"""aggregate variance on columns"""
type actor_info_variance_fields {
  actor_id: Float
}

"""
input type for inserting data into table "actor"
"""
input actor_insert_input {
  actor_id: Int
  first_name: String
  last_name: String
  last_update: timestamp
}

"""aggregate max on columns"""
type actor_max_fields {
  actor_id: Int
  first_name: String
  last_name: String
  last_update: timestamp
}

"""aggregate min on columns"""
type actor_min_fields {
  actor_id: Int
  first_name: String
  last_name: String
  last_update: timestamp
}

"""
response of any mutation on the table "actor"
"""
type actor_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [actor!]!
}

"""
on conflict condition type for table "actor"
"""
input actor_on_conflict {
  constraint: actor_constraint!
  update_columns: [actor_update_column!]! = []
  where: actor_bool_exp
}

"""Ordering options when selecting data from "actor"."""
input actor_order_by {
  actor_id: order_by
  first_name: order_by
  last_name: order_by
  last_update: order_by
}

"""primary key columns input for table: actor"""
input actor_pk_columns_input {
  actor_id: Int!
}

"""
select columns of table "actor"
"""
enum actor_select_column {
  """column name"""
  actor_id

  """column name"""
  first_name

  """column name"""
  last_name

  """column name"""
  last_update
}

"""
input type for updating data in table "actor"
"""
input actor_set_input {
  actor_id: Int
  first_name: String
  last_name: String
  last_update: timestamp
}

"""aggregate stddev on columns"""
type actor_stddev_fields {
  actor_id: Float
}

"""aggregate stddev_pop on columns"""
type actor_stddev_pop_fields {
  actor_id: Float
}

"""aggregate stddev_samp on columns"""
type actor_stddev_samp_fields {
  actor_id: Float
}

"""aggregate sum on columns"""
type actor_sum_fields {
  actor_id: Int
}

"""
update columns of table "actor"
"""
enum actor_update_column {
  """column name"""
  actor_id

  """column name"""
  first_name

  """column name"""
  last_name

  """column name"""
  last_update
}

"""aggregate var_pop on columns"""
type actor_var_pop_fields {
  actor_id: Float
}

"""aggregate var_samp on columns"""
type actor_var_samp_fields {
  actor_id: Float
}

"""aggregate variance on columns"""
type actor_variance_fields {
  actor_id: Float
}

"""
columns and relationships of "address"
"""
type address {
  address: String!
  address2: String
  address_id: Int!
  city_id: smallint!
  district: String!
  last_update: timestamp!
  phone: String!
  postal_code: String
}

"""
aggregated selection of "address"
"""
type address_aggregate {
  aggregate: address_aggregate_fields
  nodes: [address!]!
}

"""
aggregate fields of "address"
"""
type address_aggregate_fields {
  avg: address_avg_fields
  count(columns: [address_select_column!], distinct: Boolean): Int!
  max: address_max_fields
  min: address_min_fields
  stddev: address_stddev_fields
  stddev_pop: address_stddev_pop_fields
  stddev_samp: address_stddev_samp_fields
  sum: address_sum_fields
  var_pop: address_var_pop_fields
  var_samp: address_var_samp_fields
  variance: address_variance_fields
}

"""aggregate avg on columns"""
type address_avg_fields {
  address_id: Float
  city_id: Float
}

"""
Boolean expression to filter rows from the table "address". All fields are combined with a logical 'AND'.
"""
input address_bool_exp {
  _and: [address_bool_exp!]
  _not: address_bool_exp
  _or: [address_bool_exp!]
  address: String_comparison_exp
  address2: String_comparison_exp
  address_id: Int_comparison_exp
  city_id: smallint_comparison_exp
  district: String_comparison_exp
  last_update: timestamp_comparison_exp
  phone: String_comparison_exp
  postal_code: String_comparison_exp
}

"""
unique or primary key constraints on table "address"
"""
enum address_constraint {
  """unique or primary key constraint"""
  address_pkey
}

"""
input type for incrementing numeric columns in table "address"
"""
input address_inc_input {
  address_id: Int
  city_id: smallint
}

"""
input type for inserting data into table "address"
"""
input address_insert_input {
  address: String
  address2: String
  address_id: Int
  city_id: smallint
  district: String
  last_update: timestamp
  phone: String
  postal_code: String
}

"""aggregate max on columns"""
type address_max_fields {
  address: String
  address2: String
  address_id: Int
  city_id: smallint
  district: String
  last_update: timestamp
  phone: String
  postal_code: String
}

"""aggregate min on columns"""
type address_min_fields {
  address: String
  address2: String
  address_id: Int
  city_id: smallint
  district: String
  last_update: timestamp
  phone: String
  postal_code: String
}

"""
response of any mutation on the table "address"
"""
type address_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [address!]!
}

"""
on conflict condition type for table "address"
"""
input address_on_conflict {
  constraint: address_constraint!
  update_columns: [address_update_column!]! = []
  where: address_bool_exp
}

"""Ordering options when selecting data from "address"."""
input address_order_by {
  address: order_by
  address2: order_by
  address_id: order_by
  city_id: order_by
  district: order_by
  last_update: order_by
  phone: order_by
  postal_code: order_by
}

"""primary key columns input for table: address"""
input address_pk_columns_input {
  address_id: Int!
}

"""
select columns of table "address"
"""
enum address_select_column {
  """column name"""
  address

  """column name"""
  address2

  """column name"""
  address_id

  """column name"""
  city_id

  """column name"""
  district

  """column name"""
  last_update

  """column name"""
  phone

  """column name"""
  postal_code
}

"""
input type for updating data in table "address"
"""
input address_set_input {
  address: String
  address2: String
  address_id: Int
  city_id: smallint
  district: String
  last_update: timestamp
  phone: String
  postal_code: String
}

"""aggregate stddev on columns"""
type address_stddev_fields {
  address_id: Float
  city_id: Float
}

"""aggregate stddev_pop on columns"""
type address_stddev_pop_fields {
  address_id: Float
  city_id: Float
}

"""aggregate stddev_samp on columns"""
type address_stddev_samp_fields {
  address_id: Float
  city_id: Float
}

"""aggregate sum on columns"""
type address_sum_fields {
  address_id: Int
  city_id: smallint
}

"""
update columns of table "address"
"""
enum address_update_column {
  """column name"""
  address

  """column name"""
  address2

  """column name"""
  address_id

  """column name"""
  city_id

  """column name"""
  district

  """column name"""
  last_update

  """column name"""
  phone

  """column name"""
  postal_code
}

"""aggregate var_pop on columns"""
type address_var_pop_fields {
  address_id: Float
  city_id: Float
}

"""aggregate var_samp on columns"""
type address_var_samp_fields {
  address_id: Float
  city_id: Float
}

"""aggregate variance on columns"""
type address_variance_fields {
  address_id: Float
  city_id: Float
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

scalar bpchar

"""
Boolean expression to compare columns of type "bpchar". All fields are combined with logical 'AND'.
"""
input bpchar_comparison_exp {
  _eq: bpchar
  _gt: bpchar
  _gte: bpchar

  """does the column match the given case-insensitive pattern"""
  _ilike: bpchar
  _in: [bpchar!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: bpchar
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: bpchar
  _lt: bpchar
  _lte: bpchar
  _neq: bpchar

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: bpchar
  _nin: [bpchar!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: bpchar

  """does the column NOT match the given pattern"""
  _nlike: bpchar

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: bpchar

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: bpchar

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: bpchar

  """does the column match the given SQL regular expression"""
  _similar: bpchar
}

scalar bytea

"""
Boolean expression to compare columns of type "bytea". All fields are combined with logical 'AND'.
"""
input bytea_comparison_exp {
  _eq: bytea
  _gt: bytea
  _gte: bytea
  _in: [bytea!]
  _is_null: Boolean
  _lt: bytea
  _lte: bytea
  _neq: bytea
  _nin: [bytea!]
}

"""
columns and relationships of "category"
"""
type category {
  category_id: Int!
  last_update: timestamp!
  name: String!
}

"""
aggregated selection of "category"
"""
type category_aggregate {
  aggregate: category_aggregate_fields
  nodes: [category!]!
}

"""
aggregate fields of "category"
"""
type category_aggregate_fields {
  avg: category_avg_fields
  count(columns: [category_select_column!], distinct: Boolean): Int!
  max: category_max_fields
  min: category_min_fields
  stddev: category_stddev_fields
  stddev_pop: category_stddev_pop_fields
  stddev_samp: category_stddev_samp_fields
  sum: category_sum_fields
  var_pop: category_var_pop_fields
  var_samp: category_var_samp_fields
  variance: category_variance_fields
}

"""aggregate avg on columns"""
type category_avg_fields {
  category_id: Float
}

"""
Boolean expression to filter rows from the table "category". All fields are combined with a logical 'AND'.
"""
input category_bool_exp {
  _and: [category_bool_exp!]
  _not: category_bool_exp
  _or: [category_bool_exp!]
  category_id: Int_comparison_exp
  last_update: timestamp_comparison_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "category"
"""
enum category_constraint {
  """unique or primary key constraint"""
  category_pkey
}

"""
input type for incrementing numeric columns in table "category"
"""
input category_inc_input {
  category_id: Int
}

"""
input type for inserting data into table "category"
"""
input category_insert_input {
  category_id: Int
  last_update: timestamp
  name: String
}

"""aggregate max on columns"""
type category_max_fields {
  category_id: Int
  last_update: timestamp
  name: String
}

"""aggregate min on columns"""
type category_min_fields {
  category_id: Int
  last_update: timestamp
  name: String
}

"""
response of any mutation on the table "category"
"""
type category_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [category!]!
}

"""
on conflict condition type for table "category"
"""
input category_on_conflict {
  constraint: category_constraint!
  update_columns: [category_update_column!]! = []
  where: category_bool_exp
}

"""Ordering options when selecting data from "category"."""
input category_order_by {
  category_id: order_by
  last_update: order_by
  name: order_by
}

"""primary key columns input for table: category"""
input category_pk_columns_input {
  category_id: Int!
}

"""
select columns of table "category"
"""
enum category_select_column {
  """column name"""
  category_id

  """column name"""
  last_update

  """column name"""
  name
}

"""
input type for updating data in table "category"
"""
input category_set_input {
  category_id: Int
  last_update: timestamp
  name: String
}

"""aggregate stddev on columns"""
type category_stddev_fields {
  category_id: Float
}

"""aggregate stddev_pop on columns"""
type category_stddev_pop_fields {
  category_id: Float
}

"""aggregate stddev_samp on columns"""
type category_stddev_samp_fields {
  category_id: Float
}

"""aggregate sum on columns"""
type category_sum_fields {
  category_id: Int
}

"""
update columns of table "category"
"""
enum category_update_column {
  """column name"""
  category_id

  """column name"""
  last_update

  """column name"""
  name
}

"""aggregate var_pop on columns"""
type category_var_pop_fields {
  category_id: Float
}

"""aggregate var_samp on columns"""
type category_var_samp_fields {
  category_id: Float
}

"""aggregate variance on columns"""
type category_variance_fields {
  category_id: Float
}

"""
columns and relationships of "city"
"""
type city {
  city: String!
  city_id: Int!
  country_id: smallint!
  last_update: timestamp!
}

"""
aggregated selection of "city"
"""
type city_aggregate {
  aggregate: city_aggregate_fields
  nodes: [city!]!
}

"""
aggregate fields of "city"
"""
type city_aggregate_fields {
  avg: city_avg_fields
  count(columns: [city_select_column!], distinct: Boolean): Int!
  max: city_max_fields
  min: city_min_fields
  stddev: city_stddev_fields
  stddev_pop: city_stddev_pop_fields
  stddev_samp: city_stddev_samp_fields
  sum: city_sum_fields
  var_pop: city_var_pop_fields
  var_samp: city_var_samp_fields
  variance: city_variance_fields
}

"""aggregate avg on columns"""
type city_avg_fields {
  city_id: Float
  country_id: Float
}

"""
Boolean expression to filter rows from the table "city". All fields are combined with a logical 'AND'.
"""
input city_bool_exp {
  _and: [city_bool_exp!]
  _not: city_bool_exp
  _or: [city_bool_exp!]
  city: String_comparison_exp
  city_id: Int_comparison_exp
  country_id: smallint_comparison_exp
  last_update: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "city"
"""
enum city_constraint {
  """unique or primary key constraint"""
  city_pkey
}

"""
input type for incrementing numeric columns in table "city"
"""
input city_inc_input {
  city_id: Int
  country_id: smallint
}

"""
input type for inserting data into table "city"
"""
input city_insert_input {
  city: String
  city_id: Int
  country_id: smallint
  last_update: timestamp
}

"""aggregate max on columns"""
type city_max_fields {
  city: String
  city_id: Int
  country_id: smallint
  last_update: timestamp
}

"""aggregate min on columns"""
type city_min_fields {
  city: String
  city_id: Int
  country_id: smallint
  last_update: timestamp
}

"""
response of any mutation on the table "city"
"""
type city_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [city!]!
}

"""
on conflict condition type for table "city"
"""
input city_on_conflict {
  constraint: city_constraint!
  update_columns: [city_update_column!]! = []
  where: city_bool_exp
}

"""Ordering options when selecting data from "city"."""
input city_order_by {
  city: order_by
  city_id: order_by
  country_id: order_by
  last_update: order_by
}

"""primary key columns input for table: city"""
input city_pk_columns_input {
  city_id: Int!
}

"""
select columns of table "city"
"""
enum city_select_column {
  """column name"""
  city

  """column name"""
  city_id

  """column name"""
  country_id

  """column name"""
  last_update
}

"""
input type for updating data in table "city"
"""
input city_set_input {
  city: String
  city_id: Int
  country_id: smallint
  last_update: timestamp
}

"""aggregate stddev on columns"""
type city_stddev_fields {
  city_id: Float
  country_id: Float
}

"""aggregate stddev_pop on columns"""
type city_stddev_pop_fields {
  city_id: Float
  country_id: Float
}

"""aggregate stddev_samp on columns"""
type city_stddev_samp_fields {
  city_id: Float
  country_id: Float
}

"""aggregate sum on columns"""
type city_sum_fields {
  city_id: Int
  country_id: smallint
}

"""
update columns of table "city"
"""
enum city_update_column {
  """column name"""
  city

  """column name"""
  city_id

  """column name"""
  country_id

  """column name"""
  last_update
}

"""aggregate var_pop on columns"""
type city_var_pop_fields {
  city_id: Float
  country_id: Float
}

"""aggregate var_samp on columns"""
type city_var_samp_fields {
  city_id: Float
  country_id: Float
}

"""aggregate variance on columns"""
type city_variance_fields {
  city_id: Float
  country_id: Float
}

"""
columns and relationships of "country"
"""
type country {
  country: String!
  country_id: Int!
  last_update: timestamp!
}

"""
aggregated selection of "country"
"""
type country_aggregate {
  aggregate: country_aggregate_fields
  nodes: [country!]!
}

"""
aggregate fields of "country"
"""
type country_aggregate_fields {
  avg: country_avg_fields
  count(columns: [country_select_column!], distinct: Boolean): Int!
  max: country_max_fields
  min: country_min_fields
  stddev: country_stddev_fields
  stddev_pop: country_stddev_pop_fields
  stddev_samp: country_stddev_samp_fields
  sum: country_sum_fields
  var_pop: country_var_pop_fields
  var_samp: country_var_samp_fields
  variance: country_variance_fields
}

"""aggregate avg on columns"""
type country_avg_fields {
  country_id: Float
}

"""
Boolean expression to filter rows from the table "country". All fields are combined with a logical 'AND'.
"""
input country_bool_exp {
  _and: [country_bool_exp!]
  _not: country_bool_exp
  _or: [country_bool_exp!]
  country: String_comparison_exp
  country_id: Int_comparison_exp
  last_update: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "country"
"""
enum country_constraint {
  """unique or primary key constraint"""
  country_pkey
}

"""
input type for incrementing numeric columns in table "country"
"""
input country_inc_input {
  country_id: Int
}

"""
input type for inserting data into table "country"
"""
input country_insert_input {
  country: String
  country_id: Int
  last_update: timestamp
}

"""aggregate max on columns"""
type country_max_fields {
  country: String
  country_id: Int
  last_update: timestamp
}

"""aggregate min on columns"""
type country_min_fields {
  country: String
  country_id: Int
  last_update: timestamp
}

"""
response of any mutation on the table "country"
"""
type country_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [country!]!
}

"""
on conflict condition type for table "country"
"""
input country_on_conflict {
  constraint: country_constraint!
  update_columns: [country_update_column!]! = []
  where: country_bool_exp
}

"""Ordering options when selecting data from "country"."""
input country_order_by {
  country: order_by
  country_id: order_by
  last_update: order_by
}

"""primary key columns input for table: country"""
input country_pk_columns_input {
  country_id: Int!
}

"""
select columns of table "country"
"""
enum country_select_column {
  """column name"""
  country

  """column name"""
  country_id

  """column name"""
  last_update
}

"""
input type for updating data in table "country"
"""
input country_set_input {
  country: String
  country_id: Int
  last_update: timestamp
}

"""aggregate stddev on columns"""
type country_stddev_fields {
  country_id: Float
}

"""aggregate stddev_pop on columns"""
type country_stddev_pop_fields {
  country_id: Float
}

"""aggregate stddev_samp on columns"""
type country_stddev_samp_fields {
  country_id: Float
}

"""aggregate sum on columns"""
type country_sum_fields {
  country_id: Int
}

"""
update columns of table "country"
"""
enum country_update_column {
  """column name"""
  country

  """column name"""
  country_id

  """column name"""
  last_update
}

"""aggregate var_pop on columns"""
type country_var_pop_fields {
  country_id: Float
}

"""aggregate var_samp on columns"""
type country_var_samp_fields {
  country_id: Float
}

"""aggregate variance on columns"""
type country_variance_fields {
  country_id: Float
}

"""
columns and relationships of "customer"
"""
type customer {
  active: Int
  activebool: Boolean!
  address_id: smallint!
  create_date: date!
  customer_id: Int!
  email: String
  first_name: String!
  last_name: String!
  last_update: timestamp
  store_id: smallint!
}

"""
aggregated selection of "customer"
"""
type customer_aggregate {
  aggregate: customer_aggregate_fields
  nodes: [customer!]!
}

"""
aggregate fields of "customer"
"""
type customer_aggregate_fields {
  avg: customer_avg_fields
  count(columns: [customer_select_column!], distinct: Boolean): Int!
  max: customer_max_fields
  min: customer_min_fields
  stddev: customer_stddev_fields
  stddev_pop: customer_stddev_pop_fields
  stddev_samp: customer_stddev_samp_fields
  sum: customer_sum_fields
  var_pop: customer_var_pop_fields
  var_samp: customer_var_samp_fields
  variance: customer_variance_fields
}

"""aggregate avg on columns"""
type customer_avg_fields {
  active: Float
  address_id: Float
  customer_id: Float
  store_id: Float
}

"""
Boolean expression to filter rows from the table "customer". All fields are combined with a logical 'AND'.
"""
input customer_bool_exp {
  _and: [customer_bool_exp!]
  _not: customer_bool_exp
  _or: [customer_bool_exp!]
  active: Int_comparison_exp
  activebool: Boolean_comparison_exp
  address_id: smallint_comparison_exp
  create_date: date_comparison_exp
  customer_id: Int_comparison_exp
  email: String_comparison_exp
  first_name: String_comparison_exp
  last_name: String_comparison_exp
  last_update: timestamp_comparison_exp
  store_id: smallint_comparison_exp
}

"""
unique or primary key constraints on table "customer"
"""
enum customer_constraint {
  """unique or primary key constraint"""
  customer_pkey
}

"""
input type for incrementing numeric columns in table "customer"
"""
input customer_inc_input {
  active: Int
  address_id: smallint
  customer_id: Int
  store_id: smallint
}

"""
input type for inserting data into table "customer"
"""
input customer_insert_input {
  active: Int
  activebool: Boolean
  address_id: smallint
  create_date: date
  customer_id: Int
  email: String
  first_name: String
  last_name: String
  last_update: timestamp
  store_id: smallint
}

"""
columns and relationships of "customer_list"
"""
type customer_list {
  address: String
  city: String
  country: String
  id: Int
  name: String
  notes: String
  phone: String
  sid: smallint
  zip_code: String
}

"""
aggregated selection of "customer_list"
"""
type customer_list_aggregate {
  aggregate: customer_list_aggregate_fields
  nodes: [customer_list!]!
}

"""
aggregate fields of "customer_list"
"""
type customer_list_aggregate_fields {
  avg: customer_list_avg_fields
  count(columns: [customer_list_select_column!], distinct: Boolean): Int!
  max: customer_list_max_fields
  min: customer_list_min_fields
  stddev: customer_list_stddev_fields
  stddev_pop: customer_list_stddev_pop_fields
  stddev_samp: customer_list_stddev_samp_fields
  sum: customer_list_sum_fields
  var_pop: customer_list_var_pop_fields
  var_samp: customer_list_var_samp_fields
  variance: customer_list_variance_fields
}

"""aggregate avg on columns"""
type customer_list_avg_fields {
  id: Float
  sid: Float
}

"""
Boolean expression to filter rows from the table "customer_list". All fields are combined with a logical 'AND'.
"""
input customer_list_bool_exp {
  _and: [customer_list_bool_exp!]
  _not: customer_list_bool_exp
  _or: [customer_list_bool_exp!]
  address: String_comparison_exp
  city: String_comparison_exp
  country: String_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  notes: String_comparison_exp
  phone: String_comparison_exp
  sid: smallint_comparison_exp
  zip_code: String_comparison_exp
}

"""aggregate max on columns"""
type customer_list_max_fields {
  address: String
  city: String
  country: String
  id: Int
  name: String
  notes: String
  phone: String
  sid: smallint
  zip_code: String
}

"""aggregate min on columns"""
type customer_list_min_fields {
  address: String
  city: String
  country: String
  id: Int
  name: String
  notes: String
  phone: String
  sid: smallint
  zip_code: String
}

"""Ordering options when selecting data from "customer_list"."""
input customer_list_order_by {
  address: order_by
  city: order_by
  country: order_by
  id: order_by
  name: order_by
  notes: order_by
  phone: order_by
  sid: order_by
  zip_code: order_by
}

"""
select columns of table "customer_list"
"""
enum customer_list_select_column {
  """column name"""
  address

  """column name"""
  city

  """column name"""
  country

  """column name"""
  id

  """column name"""
  name

  """column name"""
  notes

  """column name"""
  phone

  """column name"""
  sid

  """column name"""
  zip_code
}

"""aggregate stddev on columns"""
type customer_list_stddev_fields {
  id: Float
  sid: Float
}

"""aggregate stddev_pop on columns"""
type customer_list_stddev_pop_fields {
  id: Float
  sid: Float
}

"""aggregate stddev_samp on columns"""
type customer_list_stddev_samp_fields {
  id: Float
  sid: Float
}

"""aggregate sum on columns"""
type customer_list_sum_fields {
  id: Int
  sid: smallint
}

"""aggregate var_pop on columns"""
type customer_list_var_pop_fields {
  id: Float
  sid: Float
}

"""aggregate var_samp on columns"""
type customer_list_var_samp_fields {
  id: Float
  sid: Float
}

"""aggregate variance on columns"""
type customer_list_variance_fields {
  id: Float
  sid: Float
}

"""aggregate max on columns"""
type customer_max_fields {
  active: Int
  address_id: smallint
  create_date: date
  customer_id: Int
  email: String
  first_name: String
  last_name: String
  last_update: timestamp
  store_id: smallint
}

"""aggregate min on columns"""
type customer_min_fields {
  active: Int
  address_id: smallint
  create_date: date
  customer_id: Int
  email: String
  first_name: String
  last_name: String
  last_update: timestamp
  store_id: smallint
}

"""
response of any mutation on the table "customer"
"""
type customer_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [customer!]!
}

"""
on conflict condition type for table "customer"
"""
input customer_on_conflict {
  constraint: customer_constraint!
  update_columns: [customer_update_column!]! = []
  where: customer_bool_exp
}

"""Ordering options when selecting data from "customer"."""
input customer_order_by {
  active: order_by
  activebool: order_by
  address_id: order_by
  create_date: order_by
  customer_id: order_by
  email: order_by
  first_name: order_by
  last_name: order_by
  last_update: order_by
  store_id: order_by
}

"""primary key columns input for table: customer"""
input customer_pk_columns_input {
  customer_id: Int!
}

"""
select columns of table "customer"
"""
enum customer_select_column {
  """column name"""
  active

  """column name"""
  activebool

  """column name"""
  address_id

  """column name"""
  create_date

  """column name"""
  customer_id

  """column name"""
  email

  """column name"""
  first_name

  """column name"""
  last_name

  """column name"""
  last_update

  """column name"""
  store_id
}

"""
input type for updating data in table "customer"
"""
input customer_set_input {
  active: Int
  activebool: Boolean
  address_id: smallint
  create_date: date
  customer_id: Int
  email: String
  first_name: String
  last_name: String
  last_update: timestamp
  store_id: smallint
}

"""aggregate stddev on columns"""
type customer_stddev_fields {
  active: Float
  address_id: Float
  customer_id: Float
  store_id: Float
}

"""aggregate stddev_pop on columns"""
type customer_stddev_pop_fields {
  active: Float
  address_id: Float
  customer_id: Float
  store_id: Float
}

"""aggregate stddev_samp on columns"""
type customer_stddev_samp_fields {
  active: Float
  address_id: Float
  customer_id: Float
  store_id: Float
}

"""aggregate sum on columns"""
type customer_sum_fields {
  active: Int
  address_id: smallint
  customer_id: Int
  store_id: smallint
}

"""
update columns of table "customer"
"""
enum customer_update_column {
  """column name"""
  active

  """column name"""
  activebool

  """column name"""
  address_id

  """column name"""
  create_date

  """column name"""
  customer_id

  """column name"""
  email

  """column name"""
  first_name

  """column name"""
  last_name

  """column name"""
  last_update

  """column name"""
  store_id
}

"""aggregate var_pop on columns"""
type customer_var_pop_fields {
  active: Float
  address_id: Float
  customer_id: Float
  store_id: Float
}

"""aggregate var_samp on columns"""
type customer_var_samp_fields {
  active: Float
  address_id: Float
  customer_id: Float
  store_id: Float
}

"""aggregate variance on columns"""
type customer_variance_fields {
  active: Float
  address_id: Float
  customer_id: Float
  store_id: Float
}

scalar date

"""
Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'.
"""
input date_comparison_exp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _is_null: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

"""
columns and relationships of "film"
"""
type film {
  description: String
  film_id: Int!
  fulltext: tsvector!
  language_id: smallint!
  last_update: timestamp!
  length: smallint
  original_language_id: smallint
  rating: mpaa_rating
  release_year: Int
  rental_duration: smallint!
  rental_rate: numeric!
  replacement_cost: numeric!
  special_features: _text
  title: String!
}

"""
columns and relationships of "film_actor"
"""
type film_actor {
  actor_id: smallint!
  film_id: smallint!
  last_update: timestamp!
}

"""
aggregated selection of "film_actor"
"""
type film_actor_aggregate {
  aggregate: film_actor_aggregate_fields
  nodes: [film_actor!]!
}

"""
aggregate fields of "film_actor"
"""
type film_actor_aggregate_fields {
  avg: film_actor_avg_fields
  count(columns: [film_actor_select_column!], distinct: Boolean): Int!
  max: film_actor_max_fields
  min: film_actor_min_fields
  stddev: film_actor_stddev_fields
  stddev_pop: film_actor_stddev_pop_fields
  stddev_samp: film_actor_stddev_samp_fields
  sum: film_actor_sum_fields
  var_pop: film_actor_var_pop_fields
  var_samp: film_actor_var_samp_fields
  variance: film_actor_variance_fields
}

"""aggregate avg on columns"""
type film_actor_avg_fields {
  actor_id: Float
  film_id: Float
}

"""
Boolean expression to filter rows from the table "film_actor". All fields are combined with a logical 'AND'.
"""
input film_actor_bool_exp {
  _and: [film_actor_bool_exp!]
  _not: film_actor_bool_exp
  _or: [film_actor_bool_exp!]
  actor_id: smallint_comparison_exp
  film_id: smallint_comparison_exp
  last_update: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "film_actor"
"""
enum film_actor_constraint {
  """unique or primary key constraint"""
  film_actor_pkey
}

"""
input type for incrementing numeric columns in table "film_actor"
"""
input film_actor_inc_input {
  actor_id: smallint
  film_id: smallint
}

"""
input type for inserting data into table "film_actor"
"""
input film_actor_insert_input {
  actor_id: smallint
  film_id: smallint
  last_update: timestamp
}

"""aggregate max on columns"""
type film_actor_max_fields {
  actor_id: smallint
  film_id: smallint
  last_update: timestamp
}

"""aggregate min on columns"""
type film_actor_min_fields {
  actor_id: smallint
  film_id: smallint
  last_update: timestamp
}

"""
response of any mutation on the table "film_actor"
"""
type film_actor_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [film_actor!]!
}

"""
on conflict condition type for table "film_actor"
"""
input film_actor_on_conflict {
  constraint: film_actor_constraint!
  update_columns: [film_actor_update_column!]! = []
  where: film_actor_bool_exp
}

"""Ordering options when selecting data from "film_actor"."""
input film_actor_order_by {
  actor_id: order_by
  film_id: order_by
  last_update: order_by
}

"""primary key columns input for table: film_actor"""
input film_actor_pk_columns_input {
  actor_id: smallint!
  film_id: smallint!
}

"""
select columns of table "film_actor"
"""
enum film_actor_select_column {
  """column name"""
  actor_id

  """column name"""
  film_id

  """column name"""
  last_update
}

"""
input type for updating data in table "film_actor"
"""
input film_actor_set_input {
  actor_id: smallint
  film_id: smallint
  last_update: timestamp
}

"""aggregate stddev on columns"""
type film_actor_stddev_fields {
  actor_id: Float
  film_id: Float
}

"""aggregate stddev_pop on columns"""
type film_actor_stddev_pop_fields {
  actor_id: Float
  film_id: Float
}

"""aggregate stddev_samp on columns"""
type film_actor_stddev_samp_fields {
  actor_id: Float
  film_id: Float
}

"""aggregate sum on columns"""
type film_actor_sum_fields {
  actor_id: smallint
  film_id: smallint
}

"""
update columns of table "film_actor"
"""
enum film_actor_update_column {
  """column name"""
  actor_id

  """column name"""
  film_id

  """column name"""
  last_update
}

"""aggregate var_pop on columns"""
type film_actor_var_pop_fields {
  actor_id: Float
  film_id: Float
}

"""aggregate var_samp on columns"""
type film_actor_var_samp_fields {
  actor_id: Float
  film_id: Float
}

"""aggregate variance on columns"""
type film_actor_variance_fields {
  actor_id: Float
  film_id: Float
}

"""
aggregated selection of "film"
"""
type film_aggregate {
  aggregate: film_aggregate_fields
  nodes: [film!]!
}

"""
aggregate fields of "film"
"""
type film_aggregate_fields {
  avg: film_avg_fields
  count(columns: [film_select_column!], distinct: Boolean): Int!
  max: film_max_fields
  min: film_min_fields
  stddev: film_stddev_fields
  stddev_pop: film_stddev_pop_fields
  stddev_samp: film_stddev_samp_fields
  sum: film_sum_fields
  var_pop: film_var_pop_fields
  var_samp: film_var_samp_fields
  variance: film_variance_fields
}

"""aggregate avg on columns"""
type film_avg_fields {
  film_id: Float
  language_id: Float
  length: Float
  original_language_id: Float
  release_year: Float
  rental_duration: Float
  rental_rate: Float
  replacement_cost: Float
}

"""
Boolean expression to filter rows from the table "film". All fields are combined with a logical 'AND'.
"""
input film_bool_exp {
  _and: [film_bool_exp!]
  _not: film_bool_exp
  _or: [film_bool_exp!]
  description: String_comparison_exp
  film_id: Int_comparison_exp
  fulltext: tsvector_comparison_exp
  language_id: smallint_comparison_exp
  last_update: timestamp_comparison_exp
  length: smallint_comparison_exp
  original_language_id: smallint_comparison_exp
  rating: mpaa_rating_comparison_exp
  release_year: Int_comparison_exp
  rental_duration: smallint_comparison_exp
  rental_rate: numeric_comparison_exp
  replacement_cost: numeric_comparison_exp
  special_features: _text_comparison_exp
  title: String_comparison_exp
}

"""
columns and relationships of "film_category"
"""
type film_category {
  category_id: smallint!
  film_id: smallint!
  last_update: timestamp!
}

"""
aggregated selection of "film_category"
"""
type film_category_aggregate {
  aggregate: film_category_aggregate_fields
  nodes: [film_category!]!
}

"""
aggregate fields of "film_category"
"""
type film_category_aggregate_fields {
  avg: film_category_avg_fields
  count(columns: [film_category_select_column!], distinct: Boolean): Int!
  max: film_category_max_fields
  min: film_category_min_fields
  stddev: film_category_stddev_fields
  stddev_pop: film_category_stddev_pop_fields
  stddev_samp: film_category_stddev_samp_fields
  sum: film_category_sum_fields
  var_pop: film_category_var_pop_fields
  var_samp: film_category_var_samp_fields
  variance: film_category_variance_fields
}

"""aggregate avg on columns"""
type film_category_avg_fields {
  category_id: Float
  film_id: Float
}

"""
Boolean expression to filter rows from the table "film_category". All fields are combined with a logical 'AND'.
"""
input film_category_bool_exp {
  _and: [film_category_bool_exp!]
  _not: film_category_bool_exp
  _or: [film_category_bool_exp!]
  category_id: smallint_comparison_exp
  film_id: smallint_comparison_exp
  last_update: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "film_category"
"""
enum film_category_constraint {
  """unique or primary key constraint"""
  film_category_pkey
}

"""
input type for incrementing numeric columns in table "film_category"
"""
input film_category_inc_input {
  category_id: smallint
  film_id: smallint
}

"""
input type for inserting data into table "film_category"
"""
input film_category_insert_input {
  category_id: smallint
  film_id: smallint
  last_update: timestamp
}

"""aggregate max on columns"""
type film_category_max_fields {
  category_id: smallint
  film_id: smallint
  last_update: timestamp
}

"""aggregate min on columns"""
type film_category_min_fields {
  category_id: smallint
  film_id: smallint
  last_update: timestamp
}

"""
response of any mutation on the table "film_category"
"""
type film_category_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [film_category!]!
}

"""
on conflict condition type for table "film_category"
"""
input film_category_on_conflict {
  constraint: film_category_constraint!
  update_columns: [film_category_update_column!]! = []
  where: film_category_bool_exp
}

"""Ordering options when selecting data from "film_category"."""
input film_category_order_by {
  category_id: order_by
  film_id: order_by
  last_update: order_by
}

"""primary key columns input for table: film_category"""
input film_category_pk_columns_input {
  category_id: smallint!
  film_id: smallint!
}

"""
select columns of table "film_category"
"""
enum film_category_select_column {
  """column name"""
  category_id

  """column name"""
  film_id

  """column name"""
  last_update
}

"""
input type for updating data in table "film_category"
"""
input film_category_set_input {
  category_id: smallint
  film_id: smallint
  last_update: timestamp
}

"""aggregate stddev on columns"""
type film_category_stddev_fields {
  category_id: Float
  film_id: Float
}

"""aggregate stddev_pop on columns"""
type film_category_stddev_pop_fields {
  category_id: Float
  film_id: Float
}

"""aggregate stddev_samp on columns"""
type film_category_stddev_samp_fields {
  category_id: Float
  film_id: Float
}

"""aggregate sum on columns"""
type film_category_sum_fields {
  category_id: smallint
  film_id: smallint
}

"""
update columns of table "film_category"
"""
enum film_category_update_column {
  """column name"""
  category_id

  """column name"""
  film_id

  """column name"""
  last_update
}

"""aggregate var_pop on columns"""
type film_category_var_pop_fields {
  category_id: Float
  film_id: Float
}

"""aggregate var_samp on columns"""
type film_category_var_samp_fields {
  category_id: Float
  film_id: Float
}

"""aggregate variance on columns"""
type film_category_variance_fields {
  category_id: Float
  film_id: Float
}

"""
unique or primary key constraints on table "film"
"""
enum film_constraint {
  """unique or primary key constraint"""
  film_pkey
}

"""
input type for incrementing numeric columns in table "film"
"""
input film_inc_input {
  film_id: Int
  language_id: smallint
  length: smallint
  original_language_id: smallint
  release_year: Int
  rental_duration: smallint
  rental_rate: numeric
  replacement_cost: numeric
}

"""
input type for inserting data into table "film"
"""
input film_insert_input {
  description: String
  film_id: Int
  fulltext: tsvector
  language_id: smallint
  last_update: timestamp
  length: smallint
  original_language_id: smallint
  rating: mpaa_rating
  release_year: Int
  rental_duration: smallint
  rental_rate: numeric
  replacement_cost: numeric
  special_features: _text
  title: String
}

"""
columns and relationships of "film_list"
"""
type film_list {
  actors: String
  category: String
  description: String
  fid: Int
  length: smallint
  price: numeric
  rating: mpaa_rating
  title: String
}

"""
aggregated selection of "film_list"
"""
type film_list_aggregate {
  aggregate: film_list_aggregate_fields
  nodes: [film_list!]!
}

"""
aggregate fields of "film_list"
"""
type film_list_aggregate_fields {
  avg: film_list_avg_fields
  count(columns: [film_list_select_column!], distinct: Boolean): Int!
  max: film_list_max_fields
  min: film_list_min_fields
  stddev: film_list_stddev_fields
  stddev_pop: film_list_stddev_pop_fields
  stddev_samp: film_list_stddev_samp_fields
  sum: film_list_sum_fields
  var_pop: film_list_var_pop_fields
  var_samp: film_list_var_samp_fields
  variance: film_list_variance_fields
}

"""aggregate avg on columns"""
type film_list_avg_fields {
  fid: Float
  length: Float
  price: Float
}

"""
Boolean expression to filter rows from the table "film_list". All fields are combined with a logical 'AND'.
"""
input film_list_bool_exp {
  _and: [film_list_bool_exp!]
  _not: film_list_bool_exp
  _or: [film_list_bool_exp!]
  actors: String_comparison_exp
  category: String_comparison_exp
  description: String_comparison_exp
  fid: Int_comparison_exp
  length: smallint_comparison_exp
  price: numeric_comparison_exp
  rating: mpaa_rating_comparison_exp
  title: String_comparison_exp
}

"""aggregate max on columns"""
type film_list_max_fields {
  actors: String
  category: String
  description: String
  fid: Int
  length: smallint
  price: numeric
  title: String
}

"""aggregate min on columns"""
type film_list_min_fields {
  actors: String
  category: String
  description: String
  fid: Int
  length: smallint
  price: numeric
  title: String
}

"""Ordering options when selecting data from "film_list"."""
input film_list_order_by {
  actors: order_by
  category: order_by
  description: order_by
  fid: order_by
  length: order_by
  price: order_by
  rating: order_by
  title: order_by
}

"""
select columns of table "film_list"
"""
enum film_list_select_column {
  """column name"""
  actors

  """column name"""
  category

  """column name"""
  description

  """column name"""
  fid

  """column name"""
  length

  """column name"""
  price

  """column name"""
  rating

  """column name"""
  title
}

"""aggregate stddev on columns"""
type film_list_stddev_fields {
  fid: Float
  length: Float
  price: Float
}

"""aggregate stddev_pop on columns"""
type film_list_stddev_pop_fields {
  fid: Float
  length: Float
  price: Float
}

"""aggregate stddev_samp on columns"""
type film_list_stddev_samp_fields {
  fid: Float
  length: Float
  price: Float
}

"""aggregate sum on columns"""
type film_list_sum_fields {
  fid: Int
  length: smallint
  price: numeric
}

"""aggregate var_pop on columns"""
type film_list_var_pop_fields {
  fid: Float
  length: Float
  price: Float
}

"""aggregate var_samp on columns"""
type film_list_var_samp_fields {
  fid: Float
  length: Float
  price: Float
}

"""aggregate variance on columns"""
type film_list_variance_fields {
  fid: Float
  length: Float
  price: Float
}

"""aggregate max on columns"""
type film_max_fields {
  description: String
  film_id: Int
  language_id: smallint
  last_update: timestamp
  length: smallint
  original_language_id: smallint
  release_year: Int
  rental_duration: smallint
  rental_rate: numeric
  replacement_cost: numeric
  title: String
}

"""aggregate min on columns"""
type film_min_fields {
  description: String
  film_id: Int
  language_id: smallint
  last_update: timestamp
  length: smallint
  original_language_id: smallint
  release_year: Int
  rental_duration: smallint
  rental_rate: numeric
  replacement_cost: numeric
  title: String
}

"""
response of any mutation on the table "film"
"""
type film_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [film!]!
}

"""
on conflict condition type for table "film"
"""
input film_on_conflict {
  constraint: film_constraint!
  update_columns: [film_update_column!]! = []
  where: film_bool_exp
}

"""Ordering options when selecting data from "film"."""
input film_order_by {
  description: order_by
  film_id: order_by
  fulltext: order_by
  language_id: order_by
  last_update: order_by
  length: order_by
  original_language_id: order_by
  rating: order_by
  release_year: order_by
  rental_duration: order_by
  rental_rate: order_by
  replacement_cost: order_by
  special_features: order_by
  title: order_by
}

"""primary key columns input for table: film"""
input film_pk_columns_input {
  film_id: Int!
}

"""
select columns of table "film"
"""
enum film_select_column {
  """column name"""
  description

  """column name"""
  film_id

  """column name"""
  fulltext

  """column name"""
  language_id

  """column name"""
  last_update

  """column name"""
  length

  """column name"""
  original_language_id

  """column name"""
  rating

  """column name"""
  release_year

  """column name"""
  rental_duration

  """column name"""
  rental_rate

  """column name"""
  replacement_cost

  """column name"""
  special_features

  """column name"""
  title
}

"""
input type for updating data in table "film"
"""
input film_set_input {
  description: String
  film_id: Int
  fulltext: tsvector
  language_id: smallint
  last_update: timestamp
  length: smallint
  original_language_id: smallint
  rating: mpaa_rating
  release_year: Int
  rental_duration: smallint
  rental_rate: numeric
  replacement_cost: numeric
  special_features: _text
  title: String
}

"""aggregate stddev on columns"""
type film_stddev_fields {
  film_id: Float
  language_id: Float
  length: Float
  original_language_id: Float
  release_year: Float
  rental_duration: Float
  rental_rate: Float
  replacement_cost: Float
}

"""aggregate stddev_pop on columns"""
type film_stddev_pop_fields {
  film_id: Float
  language_id: Float
  length: Float
  original_language_id: Float
  release_year: Float
  rental_duration: Float
  rental_rate: Float
  replacement_cost: Float
}

"""aggregate stddev_samp on columns"""
type film_stddev_samp_fields {
  film_id: Float
  language_id: Float
  length: Float
  original_language_id: Float
  release_year: Float
  rental_duration: Float
  rental_rate: Float
  replacement_cost: Float
}

"""aggregate sum on columns"""
type film_sum_fields {
  film_id: Int
  language_id: smallint
  length: smallint
  original_language_id: smallint
  release_year: Int
  rental_duration: smallint
  rental_rate: numeric
  replacement_cost: numeric
}

"""
update columns of table "film"
"""
enum film_update_column {
  """column name"""
  description

  """column name"""
  film_id

  """column name"""
  fulltext

  """column name"""
  language_id

  """column name"""
  last_update

  """column name"""
  length

  """column name"""
  original_language_id

  """column name"""
  rating

  """column name"""
  release_year

  """column name"""
  rental_duration

  """column name"""
  rental_rate

  """column name"""
  replacement_cost

  """column name"""
  special_features

  """column name"""
  title
}

"""aggregate var_pop on columns"""
type film_var_pop_fields {
  film_id: Float
  language_id: Float
  length: Float
  original_language_id: Float
  release_year: Float
  rental_duration: Float
  rental_rate: Float
  replacement_cost: Float
}

"""aggregate var_samp on columns"""
type film_var_samp_fields {
  film_id: Float
  language_id: Float
  length: Float
  original_language_id: Float
  release_year: Float
  rental_duration: Float
  rental_rate: Float
  replacement_cost: Float
}

"""aggregate variance on columns"""
type film_variance_fields {
  film_id: Float
  language_id: Float
  length: Float
  original_language_id: Float
  release_year: Float
  rental_duration: Float
  rental_rate: Float
  replacement_cost: Float
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
columns and relationships of "inventory"
"""
type inventory {
  film_id: smallint!
  inventory_id: Int!
  last_update: timestamp!
  store_id: smallint!
}

"""
aggregated selection of "inventory"
"""
type inventory_aggregate {
  aggregate: inventory_aggregate_fields
  nodes: [inventory!]!
}

"""
aggregate fields of "inventory"
"""
type inventory_aggregate_fields {
  avg: inventory_avg_fields
  count(columns: [inventory_select_column!], distinct: Boolean): Int!
  max: inventory_max_fields
  min: inventory_min_fields
  stddev: inventory_stddev_fields
  stddev_pop: inventory_stddev_pop_fields
  stddev_samp: inventory_stddev_samp_fields
  sum: inventory_sum_fields
  var_pop: inventory_var_pop_fields
  var_samp: inventory_var_samp_fields
  variance: inventory_variance_fields
}

"""aggregate avg on columns"""
type inventory_avg_fields {
  film_id: Float
  inventory_id: Float
  store_id: Float
}

"""
Boolean expression to filter rows from the table "inventory". All fields are combined with a logical 'AND'.
"""
input inventory_bool_exp {
  _and: [inventory_bool_exp!]
  _not: inventory_bool_exp
  _or: [inventory_bool_exp!]
  film_id: smallint_comparison_exp
  inventory_id: Int_comparison_exp
  last_update: timestamp_comparison_exp
  store_id: smallint_comparison_exp
}

"""
unique or primary key constraints on table "inventory"
"""
enum inventory_constraint {
  """unique or primary key constraint"""
  inventory_pkey
}

"""
input type for incrementing numeric columns in table "inventory"
"""
input inventory_inc_input {
  film_id: smallint
  inventory_id: Int
  store_id: smallint
}

"""
input type for inserting data into table "inventory"
"""
input inventory_insert_input {
  film_id: smallint
  inventory_id: Int
  last_update: timestamp
  store_id: smallint
}

"""aggregate max on columns"""
type inventory_max_fields {
  film_id: smallint
  inventory_id: Int
  last_update: timestamp
  store_id: smallint
}

"""aggregate min on columns"""
type inventory_min_fields {
  film_id: smallint
  inventory_id: Int
  last_update: timestamp
  store_id: smallint
}

"""
response of any mutation on the table "inventory"
"""
type inventory_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [inventory!]!
}

"""
on conflict condition type for table "inventory"
"""
input inventory_on_conflict {
  constraint: inventory_constraint!
  update_columns: [inventory_update_column!]! = []
  where: inventory_bool_exp
}

"""Ordering options when selecting data from "inventory"."""
input inventory_order_by {
  film_id: order_by
  inventory_id: order_by
  last_update: order_by
  store_id: order_by
}

"""primary key columns input for table: inventory"""
input inventory_pk_columns_input {
  inventory_id: Int!
}

"""
select columns of table "inventory"
"""
enum inventory_select_column {
  """column name"""
  film_id

  """column name"""
  inventory_id

  """column name"""
  last_update

  """column name"""
  store_id
}

"""
input type for updating data in table "inventory"
"""
input inventory_set_input {
  film_id: smallint
  inventory_id: Int
  last_update: timestamp
  store_id: smallint
}

"""aggregate stddev on columns"""
type inventory_stddev_fields {
  film_id: Float
  inventory_id: Float
  store_id: Float
}

"""aggregate stddev_pop on columns"""
type inventory_stddev_pop_fields {
  film_id: Float
  inventory_id: Float
  store_id: Float
}

"""aggregate stddev_samp on columns"""
type inventory_stddev_samp_fields {
  film_id: Float
  inventory_id: Float
  store_id: Float
}

"""aggregate sum on columns"""
type inventory_sum_fields {
  film_id: smallint
  inventory_id: Int
  store_id: smallint
}

"""
update columns of table "inventory"
"""
enum inventory_update_column {
  """column name"""
  film_id

  """column name"""
  inventory_id

  """column name"""
  last_update

  """column name"""
  store_id
}

"""aggregate var_pop on columns"""
type inventory_var_pop_fields {
  film_id: Float
  inventory_id: Float
  store_id: Float
}

"""aggregate var_samp on columns"""
type inventory_var_samp_fields {
  film_id: Float
  inventory_id: Float
  store_id: Float
}

"""aggregate variance on columns"""
type inventory_variance_fields {
  film_id: Float
  inventory_id: Float
  store_id: Float
}

"""
columns and relationships of "language"
"""
type language {
  language_id: Int!
  last_update: timestamp!
  name: bpchar!
}

"""
aggregated selection of "language"
"""
type language_aggregate {
  aggregate: language_aggregate_fields
  nodes: [language!]!
}

"""
aggregate fields of "language"
"""
type language_aggregate_fields {
  avg: language_avg_fields
  count(columns: [language_select_column!], distinct: Boolean): Int!
  max: language_max_fields
  min: language_min_fields
  stddev: language_stddev_fields
  stddev_pop: language_stddev_pop_fields
  stddev_samp: language_stddev_samp_fields
  sum: language_sum_fields
  var_pop: language_var_pop_fields
  var_samp: language_var_samp_fields
  variance: language_variance_fields
}

"""aggregate avg on columns"""
type language_avg_fields {
  language_id: Float
}

"""
Boolean expression to filter rows from the table "language". All fields are combined with a logical 'AND'.
"""
input language_bool_exp {
  _and: [language_bool_exp!]
  _not: language_bool_exp
  _or: [language_bool_exp!]
  language_id: Int_comparison_exp
  last_update: timestamp_comparison_exp
  name: bpchar_comparison_exp
}

"""
unique or primary key constraints on table "language"
"""
enum language_constraint {
  """unique or primary key constraint"""
  language_pkey
}

"""
input type for incrementing numeric columns in table "language"
"""
input language_inc_input {
  language_id: Int
}

"""
input type for inserting data into table "language"
"""
input language_insert_input {
  language_id: Int
  last_update: timestamp
  name: bpchar
}

"""aggregate max on columns"""
type language_max_fields {
  language_id: Int
  last_update: timestamp
  name: bpchar
}

"""aggregate min on columns"""
type language_min_fields {
  language_id: Int
  last_update: timestamp
  name: bpchar
}

"""
response of any mutation on the table "language"
"""
type language_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [language!]!
}

"""
on conflict condition type for table "language"
"""
input language_on_conflict {
  constraint: language_constraint!
  update_columns: [language_update_column!]! = []
  where: language_bool_exp
}

"""Ordering options when selecting data from "language"."""
input language_order_by {
  language_id: order_by
  last_update: order_by
  name: order_by
}

"""primary key columns input for table: language"""
input language_pk_columns_input {
  language_id: Int!
}

"""
select columns of table "language"
"""
enum language_select_column {
  """column name"""
  language_id

  """column name"""
  last_update

  """column name"""
  name
}

"""
input type for updating data in table "language"
"""
input language_set_input {
  language_id: Int
  last_update: timestamp
  name: bpchar
}

"""aggregate stddev on columns"""
type language_stddev_fields {
  language_id: Float
}

"""aggregate stddev_pop on columns"""
type language_stddev_pop_fields {
  language_id: Float
}

"""aggregate stddev_samp on columns"""
type language_stddev_samp_fields {
  language_id: Float
}

"""aggregate sum on columns"""
type language_sum_fields {
  language_id: Int
}

"""
update columns of table "language"
"""
enum language_update_column {
  """column name"""
  language_id

  """column name"""
  last_update

  """column name"""
  name
}

"""aggregate var_pop on columns"""
type language_var_pop_fields {
  language_id: Float
}

"""aggregate var_samp on columns"""
type language_var_samp_fields {
  language_id: Float
}

"""aggregate variance on columns"""
type language_variance_fields {
  language_id: Float
}

scalar mpaa_rating

"""
Boolean expression to compare columns of type "mpaa_rating". All fields are combined with logical 'AND'.
"""
input mpaa_rating_comparison_exp {
  _eq: mpaa_rating
  _gt: mpaa_rating
  _gte: mpaa_rating
  _in: [mpaa_rating!]
  _is_null: Boolean
  _lt: mpaa_rating
  _lte: mpaa_rating
  _neq: mpaa_rating
  _nin: [mpaa_rating!]
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "actor"
  """
  delete_actor(
    """filter the rows which have to be deleted"""
    where: actor_bool_exp!
  ): actor_mutation_response

  """
  delete single row from the table: "actor"
  """
  delete_actor_by_pk(actor_id: Int!): actor

  """
  delete data from the table: "address"
  """
  delete_address(
    """filter the rows which have to be deleted"""
    where: address_bool_exp!
  ): address_mutation_response

  """
  delete single row from the table: "address"
  """
  delete_address_by_pk(address_id: Int!): address

  """
  delete data from the table: "category"
  """
  delete_category(
    """filter the rows which have to be deleted"""
    where: category_bool_exp!
  ): category_mutation_response

  """
  delete single row from the table: "category"
  """
  delete_category_by_pk(category_id: Int!): category

  """
  delete data from the table: "city"
  """
  delete_city(
    """filter the rows which have to be deleted"""
    where: city_bool_exp!
  ): city_mutation_response

  """
  delete single row from the table: "city"
  """
  delete_city_by_pk(city_id: Int!): city

  """
  delete data from the table: "country"
  """
  delete_country(
    """filter the rows which have to be deleted"""
    where: country_bool_exp!
  ): country_mutation_response

  """
  delete single row from the table: "country"
  """
  delete_country_by_pk(country_id: Int!): country

  """
  delete data from the table: "customer"
  """
  delete_customer(
    """filter the rows which have to be deleted"""
    where: customer_bool_exp!
  ): customer_mutation_response

  """
  delete single row from the table: "customer"
  """
  delete_customer_by_pk(customer_id: Int!): customer

  """
  delete data from the table: "film"
  """
  delete_film(
    """filter the rows which have to be deleted"""
    where: film_bool_exp!
  ): film_mutation_response

  """
  delete data from the table: "film_actor"
  """
  delete_film_actor(
    """filter the rows which have to be deleted"""
    where: film_actor_bool_exp!
  ): film_actor_mutation_response

  """
  delete single row from the table: "film_actor"
  """
  delete_film_actor_by_pk(actor_id: smallint!, film_id: smallint!): film_actor

  """
  delete single row from the table: "film"
  """
  delete_film_by_pk(film_id: Int!): film

  """
  delete data from the table: "film_category"
  """
  delete_film_category(
    """filter the rows which have to be deleted"""
    where: film_category_bool_exp!
  ): film_category_mutation_response

  """
  delete single row from the table: "film_category"
  """
  delete_film_category_by_pk(category_id: smallint!, film_id: smallint!): film_category

  """
  delete data from the table: "inventory"
  """
  delete_inventory(
    """filter the rows which have to be deleted"""
    where: inventory_bool_exp!
  ): inventory_mutation_response

  """
  delete single row from the table: "inventory"
  """
  delete_inventory_by_pk(inventory_id: Int!): inventory

  """
  delete data from the table: "language"
  """
  delete_language(
    """filter the rows which have to be deleted"""
    where: language_bool_exp!
  ): language_mutation_response

  """
  delete single row from the table: "language"
  """
  delete_language_by_pk(language_id: Int!): language

  """
  delete data from the table: "payment"
  """
  delete_payment(
    """filter the rows which have to be deleted"""
    where: payment_bool_exp!
  ): payment_mutation_response

  """
  delete single row from the table: "payment"
  """
  delete_payment_by_pk(payment_id: Int!): payment

  """
  delete data from the table: "payment_p2007_01"
  """
  delete_payment_p2007_01(
    """filter the rows which have to be deleted"""
    where: payment_p2007_01_bool_exp!
  ): payment_p2007_01_mutation_response

  """
  delete data from the table: "payment_p2007_02"
  """
  delete_payment_p2007_02(
    """filter the rows which have to be deleted"""
    where: payment_p2007_02_bool_exp!
  ): payment_p2007_02_mutation_response

  """
  delete data from the table: "payment_p2007_03"
  """
  delete_payment_p2007_03(
    """filter the rows which have to be deleted"""
    where: payment_p2007_03_bool_exp!
  ): payment_p2007_03_mutation_response

  """
  delete data from the table: "payment_p2007_04"
  """
  delete_payment_p2007_04(
    """filter the rows which have to be deleted"""
    where: payment_p2007_04_bool_exp!
  ): payment_p2007_04_mutation_response

  """
  delete data from the table: "payment_p2007_05"
  """
  delete_payment_p2007_05(
    """filter the rows which have to be deleted"""
    where: payment_p2007_05_bool_exp!
  ): payment_p2007_05_mutation_response

  """
  delete data from the table: "payment_p2007_06"
  """
  delete_payment_p2007_06(
    """filter the rows which have to be deleted"""
    where: payment_p2007_06_bool_exp!
  ): payment_p2007_06_mutation_response

  """
  delete data from the table: "rental"
  """
  delete_rental(
    """filter the rows which have to be deleted"""
    where: rental_bool_exp!
  ): rental_mutation_response

  """
  delete single row from the table: "rental"
  """
  delete_rental_by_pk(rental_id: Int!): rental

  """
  delete data from the table: "staff"
  """
  delete_staff(
    """filter the rows which have to be deleted"""
    where: staff_bool_exp!
  ): staff_mutation_response

  """
  delete single row from the table: "staff"
  """
  delete_staff_by_pk(staff_id: Int!): staff

  """
  delete data from the table: "store"
  """
  delete_store(
    """filter the rows which have to be deleted"""
    where: store_bool_exp!
  ): store_mutation_response

  """
  delete single row from the table: "store"
  """
  delete_store_by_pk(store_id: Int!): store

  """
  insert data into the table: "actor"
  """
  insert_actor(
    """the rows to be inserted"""
    objects: [actor_insert_input!]!

    """on conflict condition"""
    on_conflict: actor_on_conflict
  ): actor_mutation_response

  """
  insert a single row into the table: "actor"
  """
  insert_actor_one(
    """the row to be inserted"""
    object: actor_insert_input!

    """on conflict condition"""
    on_conflict: actor_on_conflict
  ): actor

  """
  insert data into the table: "address"
  """
  insert_address(
    """the rows to be inserted"""
    objects: [address_insert_input!]!

    """on conflict condition"""
    on_conflict: address_on_conflict
  ): address_mutation_response

  """
  insert a single row into the table: "address"
  """
  insert_address_one(
    """the row to be inserted"""
    object: address_insert_input!

    """on conflict condition"""
    on_conflict: address_on_conflict
  ): address

  """
  insert data into the table: "category"
  """
  insert_category(
    """the rows to be inserted"""
    objects: [category_insert_input!]!

    """on conflict condition"""
    on_conflict: category_on_conflict
  ): category_mutation_response

  """
  insert a single row into the table: "category"
  """
  insert_category_one(
    """the row to be inserted"""
    object: category_insert_input!

    """on conflict condition"""
    on_conflict: category_on_conflict
  ): category

  """
  insert data into the table: "city"
  """
  insert_city(
    """the rows to be inserted"""
    objects: [city_insert_input!]!

    """on conflict condition"""
    on_conflict: city_on_conflict
  ): city_mutation_response

  """
  insert a single row into the table: "city"
  """
  insert_city_one(
    """the row to be inserted"""
    object: city_insert_input!

    """on conflict condition"""
    on_conflict: city_on_conflict
  ): city

  """
  insert data into the table: "country"
  """
  insert_country(
    """the rows to be inserted"""
    objects: [country_insert_input!]!

    """on conflict condition"""
    on_conflict: country_on_conflict
  ): country_mutation_response

  """
  insert a single row into the table: "country"
  """
  insert_country_one(
    """the row to be inserted"""
    object: country_insert_input!

    """on conflict condition"""
    on_conflict: country_on_conflict
  ): country

  """
  insert data into the table: "customer"
  """
  insert_customer(
    """the rows to be inserted"""
    objects: [customer_insert_input!]!

    """on conflict condition"""
    on_conflict: customer_on_conflict
  ): customer_mutation_response

  """
  insert a single row into the table: "customer"
  """
  insert_customer_one(
    """the row to be inserted"""
    object: customer_insert_input!

    """on conflict condition"""
    on_conflict: customer_on_conflict
  ): customer

  """
  insert data into the table: "film"
  """
  insert_film(
    """the rows to be inserted"""
    objects: [film_insert_input!]!

    """on conflict condition"""
    on_conflict: film_on_conflict
  ): film_mutation_response

  """
  insert data into the table: "film_actor"
  """
  insert_film_actor(
    """the rows to be inserted"""
    objects: [film_actor_insert_input!]!

    """on conflict condition"""
    on_conflict: film_actor_on_conflict
  ): film_actor_mutation_response

  """
  insert a single row into the table: "film_actor"
  """
  insert_film_actor_one(
    """the row to be inserted"""
    object: film_actor_insert_input!

    """on conflict condition"""
    on_conflict: film_actor_on_conflict
  ): film_actor

  """
  insert data into the table: "film_category"
  """
  insert_film_category(
    """the rows to be inserted"""
    objects: [film_category_insert_input!]!

    """on conflict condition"""
    on_conflict: film_category_on_conflict
  ): film_category_mutation_response

  """
  insert a single row into the table: "film_category"
  """
  insert_film_category_one(
    """the row to be inserted"""
    object: film_category_insert_input!

    """on conflict condition"""
    on_conflict: film_category_on_conflict
  ): film_category

  """
  insert a single row into the table: "film"
  """
  insert_film_one(
    """the row to be inserted"""
    object: film_insert_input!

    """on conflict condition"""
    on_conflict: film_on_conflict
  ): film

  """
  insert data into the table: "inventory"
  """
  insert_inventory(
    """the rows to be inserted"""
    objects: [inventory_insert_input!]!

    """on conflict condition"""
    on_conflict: inventory_on_conflict
  ): inventory_mutation_response

  """
  insert a single row into the table: "inventory"
  """
  insert_inventory_one(
    """the row to be inserted"""
    object: inventory_insert_input!

    """on conflict condition"""
    on_conflict: inventory_on_conflict
  ): inventory

  """
  insert data into the table: "language"
  """
  insert_language(
    """the rows to be inserted"""
    objects: [language_insert_input!]!

    """on conflict condition"""
    on_conflict: language_on_conflict
  ): language_mutation_response

  """
  insert a single row into the table: "language"
  """
  insert_language_one(
    """the row to be inserted"""
    object: language_insert_input!

    """on conflict condition"""
    on_conflict: language_on_conflict
  ): language

  """
  insert data into the table: "payment"
  """
  insert_payment(
    """the rows to be inserted"""
    objects: [payment_insert_input!]!

    """on conflict condition"""
    on_conflict: payment_on_conflict
  ): payment_mutation_response

  """
  insert a single row into the table: "payment"
  """
  insert_payment_one(
    """the row to be inserted"""
    object: payment_insert_input!

    """on conflict condition"""
    on_conflict: payment_on_conflict
  ): payment

  """
  insert data into the table: "payment_p2007_01"
  """
  insert_payment_p2007_01(
    """the rows to be inserted"""
    objects: [payment_p2007_01_insert_input!]!
  ): payment_p2007_01_mutation_response

  """
  insert a single row into the table: "payment_p2007_01"
  """
  insert_payment_p2007_01_one(
    """the row to be inserted"""
    object: payment_p2007_01_insert_input!
  ): payment_p2007_01

  """
  insert data into the table: "payment_p2007_02"
  """
  insert_payment_p2007_02(
    """the rows to be inserted"""
    objects: [payment_p2007_02_insert_input!]!
  ): payment_p2007_02_mutation_response

  """
  insert a single row into the table: "payment_p2007_02"
  """
  insert_payment_p2007_02_one(
    """the row to be inserted"""
    object: payment_p2007_02_insert_input!
  ): payment_p2007_02

  """
  insert data into the table: "payment_p2007_03"
  """
  insert_payment_p2007_03(
    """the rows to be inserted"""
    objects: [payment_p2007_03_insert_input!]!
  ): payment_p2007_03_mutation_response

  """
  insert a single row into the table: "payment_p2007_03"
  """
  insert_payment_p2007_03_one(
    """the row to be inserted"""
    object: payment_p2007_03_insert_input!
  ): payment_p2007_03

  """
  insert data into the table: "payment_p2007_04"
  """
  insert_payment_p2007_04(
    """the rows to be inserted"""
    objects: [payment_p2007_04_insert_input!]!
  ): payment_p2007_04_mutation_response

  """
  insert a single row into the table: "payment_p2007_04"
  """
  insert_payment_p2007_04_one(
    """the row to be inserted"""
    object: payment_p2007_04_insert_input!
  ): payment_p2007_04

  """
  insert data into the table: "payment_p2007_05"
  """
  insert_payment_p2007_05(
    """the rows to be inserted"""
    objects: [payment_p2007_05_insert_input!]!
  ): payment_p2007_05_mutation_response

  """
  insert a single row into the table: "payment_p2007_05"
  """
  insert_payment_p2007_05_one(
    """the row to be inserted"""
    object: payment_p2007_05_insert_input!
  ): payment_p2007_05

  """
  insert data into the table: "payment_p2007_06"
  """
  insert_payment_p2007_06(
    """the rows to be inserted"""
    objects: [payment_p2007_06_insert_input!]!
  ): payment_p2007_06_mutation_response

  """
  insert a single row into the table: "payment_p2007_06"
  """
  insert_payment_p2007_06_one(
    """the row to be inserted"""
    object: payment_p2007_06_insert_input!
  ): payment_p2007_06

  """
  insert data into the table: "rental"
  """
  insert_rental(
    """the rows to be inserted"""
    objects: [rental_insert_input!]!

    """on conflict condition"""
    on_conflict: rental_on_conflict
  ): rental_mutation_response

  """
  insert a single row into the table: "rental"
  """
  insert_rental_one(
    """the row to be inserted"""
    object: rental_insert_input!

    """on conflict condition"""
    on_conflict: rental_on_conflict
  ): rental

  """
  insert data into the table: "staff"
  """
  insert_staff(
    """the rows to be inserted"""
    objects: [staff_insert_input!]!

    """on conflict condition"""
    on_conflict: staff_on_conflict
  ): staff_mutation_response

  """
  insert a single row into the table: "staff"
  """
  insert_staff_one(
    """the row to be inserted"""
    object: staff_insert_input!

    """on conflict condition"""
    on_conflict: staff_on_conflict
  ): staff

  """
  insert data into the table: "store"
  """
  insert_store(
    """the rows to be inserted"""
    objects: [store_insert_input!]!

    """on conflict condition"""
    on_conflict: store_on_conflict
  ): store_mutation_response

  """
  insert a single row into the table: "store"
  """
  insert_store_one(
    """the row to be inserted"""
    object: store_insert_input!

    """on conflict condition"""
    on_conflict: store_on_conflict
  ): store

  """
  update data of the table: "actor"
  """
  update_actor(
    """increments the numeric columns with given value of the filtered values"""
    _inc: actor_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: actor_set_input

    """filter the rows which have to be updated"""
    where: actor_bool_exp!
  ): actor_mutation_response

  """
  update single row of the table: "actor"
  """
  update_actor_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: actor_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: actor_set_input
    pk_columns: actor_pk_columns_input!
  ): actor

  """
  update data of the table: "address"
  """
  update_address(
    """increments the numeric columns with given value of the filtered values"""
    _inc: address_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: address_set_input

    """filter the rows which have to be updated"""
    where: address_bool_exp!
  ): address_mutation_response

  """
  update single row of the table: "address"
  """
  update_address_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: address_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: address_set_input
    pk_columns: address_pk_columns_input!
  ): address

  """
  update data of the table: "category"
  """
  update_category(
    """increments the numeric columns with given value of the filtered values"""
    _inc: category_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: category_set_input

    """filter the rows which have to be updated"""
    where: category_bool_exp!
  ): category_mutation_response

  """
  update single row of the table: "category"
  """
  update_category_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: category_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: category_set_input
    pk_columns: category_pk_columns_input!
  ): category

  """
  update data of the table: "city"
  """
  update_city(
    """increments the numeric columns with given value of the filtered values"""
    _inc: city_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: city_set_input

    """filter the rows which have to be updated"""
    where: city_bool_exp!
  ): city_mutation_response

  """
  update single row of the table: "city"
  """
  update_city_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: city_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: city_set_input
    pk_columns: city_pk_columns_input!
  ): city

  """
  update data of the table: "country"
  """
  update_country(
    """increments the numeric columns with given value of the filtered values"""
    _inc: country_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: country_set_input

    """filter the rows which have to be updated"""
    where: country_bool_exp!
  ): country_mutation_response

  """
  update single row of the table: "country"
  """
  update_country_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: country_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: country_set_input
    pk_columns: country_pk_columns_input!
  ): country

  """
  update data of the table: "customer"
  """
  update_customer(
    """increments the numeric columns with given value of the filtered values"""
    _inc: customer_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: customer_set_input

    """filter the rows which have to be updated"""
    where: customer_bool_exp!
  ): customer_mutation_response

  """
  update single row of the table: "customer"
  """
  update_customer_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: customer_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: customer_set_input
    pk_columns: customer_pk_columns_input!
  ): customer

  """
  update data of the table: "film"
  """
  update_film(
    """increments the numeric columns with given value of the filtered values"""
    _inc: film_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: film_set_input

    """filter the rows which have to be updated"""
    where: film_bool_exp!
  ): film_mutation_response

  """
  update data of the table: "film_actor"
  """
  update_film_actor(
    """increments the numeric columns with given value of the filtered values"""
    _inc: film_actor_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: film_actor_set_input

    """filter the rows which have to be updated"""
    where: film_actor_bool_exp!
  ): film_actor_mutation_response

  """
  update single row of the table: "film_actor"
  """
  update_film_actor_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: film_actor_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: film_actor_set_input
    pk_columns: film_actor_pk_columns_input!
  ): film_actor

  """
  update single row of the table: "film"
  """
  update_film_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: film_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: film_set_input
    pk_columns: film_pk_columns_input!
  ): film

  """
  update data of the table: "film_category"
  """
  update_film_category(
    """increments the numeric columns with given value of the filtered values"""
    _inc: film_category_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: film_category_set_input

    """filter the rows which have to be updated"""
    where: film_category_bool_exp!
  ): film_category_mutation_response

  """
  update single row of the table: "film_category"
  """
  update_film_category_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: film_category_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: film_category_set_input
    pk_columns: film_category_pk_columns_input!
  ): film_category

  """
  update data of the table: "inventory"
  """
  update_inventory(
    """increments the numeric columns with given value of the filtered values"""
    _inc: inventory_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: inventory_set_input

    """filter the rows which have to be updated"""
    where: inventory_bool_exp!
  ): inventory_mutation_response

  """
  update single row of the table: "inventory"
  """
  update_inventory_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: inventory_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: inventory_set_input
    pk_columns: inventory_pk_columns_input!
  ): inventory

  """
  update data of the table: "language"
  """
  update_language(
    """increments the numeric columns with given value of the filtered values"""
    _inc: language_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: language_set_input

    """filter the rows which have to be updated"""
    where: language_bool_exp!
  ): language_mutation_response

  """
  update single row of the table: "language"
  """
  update_language_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: language_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: language_set_input
    pk_columns: language_pk_columns_input!
  ): language

  """
  update data of the table: "payment"
  """
  update_payment(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payment_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payment_set_input

    """filter the rows which have to be updated"""
    where: payment_bool_exp!
  ): payment_mutation_response

  """
  update single row of the table: "payment"
  """
  update_payment_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payment_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payment_set_input
    pk_columns: payment_pk_columns_input!
  ): payment

  """
  update data of the table: "payment_p2007_01"
  """
  update_payment_p2007_01(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payment_p2007_01_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payment_p2007_01_set_input

    """filter the rows which have to be updated"""
    where: payment_p2007_01_bool_exp!
  ): payment_p2007_01_mutation_response

  """
  update data of the table: "payment_p2007_02"
  """
  update_payment_p2007_02(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payment_p2007_02_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payment_p2007_02_set_input

    """filter the rows which have to be updated"""
    where: payment_p2007_02_bool_exp!
  ): payment_p2007_02_mutation_response

  """
  update data of the table: "payment_p2007_03"
  """
  update_payment_p2007_03(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payment_p2007_03_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payment_p2007_03_set_input

    """filter the rows which have to be updated"""
    where: payment_p2007_03_bool_exp!
  ): payment_p2007_03_mutation_response

  """
  update data of the table: "payment_p2007_04"
  """
  update_payment_p2007_04(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payment_p2007_04_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payment_p2007_04_set_input

    """filter the rows which have to be updated"""
    where: payment_p2007_04_bool_exp!
  ): payment_p2007_04_mutation_response

  """
  update data of the table: "payment_p2007_05"
  """
  update_payment_p2007_05(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payment_p2007_05_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payment_p2007_05_set_input

    """filter the rows which have to be updated"""
    where: payment_p2007_05_bool_exp!
  ): payment_p2007_05_mutation_response

  """
  update data of the table: "payment_p2007_06"
  """
  update_payment_p2007_06(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payment_p2007_06_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payment_p2007_06_set_input

    """filter the rows which have to be updated"""
    where: payment_p2007_06_bool_exp!
  ): payment_p2007_06_mutation_response

  """
  update data of the table: "rental"
  """
  update_rental(
    """increments the numeric columns with given value of the filtered values"""
    _inc: rental_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: rental_set_input

    """filter the rows which have to be updated"""
    where: rental_bool_exp!
  ): rental_mutation_response

  """
  update single row of the table: "rental"
  """
  update_rental_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: rental_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: rental_set_input
    pk_columns: rental_pk_columns_input!
  ): rental

  """
  update data of the table: "staff"
  """
  update_staff(
    """increments the numeric columns with given value of the filtered values"""
    _inc: staff_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: staff_set_input

    """filter the rows which have to be updated"""
    where: staff_bool_exp!
  ): staff_mutation_response

  """
  update single row of the table: "staff"
  """
  update_staff_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: staff_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: staff_set_input
    pk_columns: staff_pk_columns_input!
  ): staff

  """
  update data of the table: "store"
  """
  update_store(
    """increments the numeric columns with given value of the filtered values"""
    _inc: store_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: store_set_input

    """filter the rows which have to be updated"""
    where: store_bool_exp!
  ): store_mutation_response

  """
  update single row of the table: "store"
  """
  update_store_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: store_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: store_set_input
    pk_columns: store_pk_columns_input!
  ): store
}

"""
columns and relationships of "nicer_but_slower_film_list"
"""
type nicer_but_slower_film_list {
  actors: String
  category: String
  description: String
  fid: Int
  length: smallint
  price: numeric
  rating: mpaa_rating
  title: String
}

"""
aggregated selection of "nicer_but_slower_film_list"
"""
type nicer_but_slower_film_list_aggregate {
  aggregate: nicer_but_slower_film_list_aggregate_fields
  nodes: [nicer_but_slower_film_list!]!
}

"""
aggregate fields of "nicer_but_slower_film_list"
"""
type nicer_but_slower_film_list_aggregate_fields {
  avg: nicer_but_slower_film_list_avg_fields
  count(columns: [nicer_but_slower_film_list_select_column!], distinct: Boolean): Int!
  max: nicer_but_slower_film_list_max_fields
  min: nicer_but_slower_film_list_min_fields
  stddev: nicer_but_slower_film_list_stddev_fields
  stddev_pop: nicer_but_slower_film_list_stddev_pop_fields
  stddev_samp: nicer_but_slower_film_list_stddev_samp_fields
  sum: nicer_but_slower_film_list_sum_fields
  var_pop: nicer_but_slower_film_list_var_pop_fields
  var_samp: nicer_but_slower_film_list_var_samp_fields
  variance: nicer_but_slower_film_list_variance_fields
}

"""aggregate avg on columns"""
type nicer_but_slower_film_list_avg_fields {
  fid: Float
  length: Float
  price: Float
}

"""
Boolean expression to filter rows from the table "nicer_but_slower_film_list". All fields are combined with a logical 'AND'.
"""
input nicer_but_slower_film_list_bool_exp {
  _and: [nicer_but_slower_film_list_bool_exp!]
  _not: nicer_but_slower_film_list_bool_exp
  _or: [nicer_but_slower_film_list_bool_exp!]
  actors: String_comparison_exp
  category: String_comparison_exp
  description: String_comparison_exp
  fid: Int_comparison_exp
  length: smallint_comparison_exp
  price: numeric_comparison_exp
  rating: mpaa_rating_comparison_exp
  title: String_comparison_exp
}

"""aggregate max on columns"""
type nicer_but_slower_film_list_max_fields {
  actors: String
  category: String
  description: String
  fid: Int
  length: smallint
  price: numeric
  title: String
}

"""aggregate min on columns"""
type nicer_but_slower_film_list_min_fields {
  actors: String
  category: String
  description: String
  fid: Int
  length: smallint
  price: numeric
  title: String
}

"""
Ordering options when selecting data from "nicer_but_slower_film_list".
"""
input nicer_but_slower_film_list_order_by {
  actors: order_by
  category: order_by
  description: order_by
  fid: order_by
  length: order_by
  price: order_by
  rating: order_by
  title: order_by
}

"""
select columns of table "nicer_but_slower_film_list"
"""
enum nicer_but_slower_film_list_select_column {
  """column name"""
  actors

  """column name"""
  category

  """column name"""
  description

  """column name"""
  fid

  """column name"""
  length

  """column name"""
  price

  """column name"""
  rating

  """column name"""
  title
}

"""aggregate stddev on columns"""
type nicer_but_slower_film_list_stddev_fields {
  fid: Float
  length: Float
  price: Float
}

"""aggregate stddev_pop on columns"""
type nicer_but_slower_film_list_stddev_pop_fields {
  fid: Float
  length: Float
  price: Float
}

"""aggregate stddev_samp on columns"""
type nicer_but_slower_film_list_stddev_samp_fields {
  fid: Float
  length: Float
  price: Float
}

"""aggregate sum on columns"""
type nicer_but_slower_film_list_sum_fields {
  fid: Int
  length: smallint
  price: numeric
}

"""aggregate var_pop on columns"""
type nicer_but_slower_film_list_var_pop_fields {
  fid: Float
  length: Float
  price: Float
}

"""aggregate var_samp on columns"""
type nicer_but_slower_film_list_var_samp_fields {
  fid: Float
  length: Float
  price: Float
}

"""aggregate variance on columns"""
type nicer_but_slower_film_list_variance_fields {
  fid: Float
  length: Float
  price: Float
}

scalar numeric

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "payment"
"""
type payment {
  amount: numeric!
  customer_id: smallint!
  payment_date: timestamp!
  payment_id: Int!
  rental_id: Int!
  staff_id: smallint!
}

"""
aggregated selection of "payment"
"""
type payment_aggregate {
  aggregate: payment_aggregate_fields
  nodes: [payment!]!
}

"""
aggregate fields of "payment"
"""
type payment_aggregate_fields {
  avg: payment_avg_fields
  count(columns: [payment_select_column!], distinct: Boolean): Int!
  max: payment_max_fields
  min: payment_min_fields
  stddev: payment_stddev_fields
  stddev_pop: payment_stddev_pop_fields
  stddev_samp: payment_stddev_samp_fields
  sum: payment_sum_fields
  var_pop: payment_var_pop_fields
  var_samp: payment_var_samp_fields
  variance: payment_variance_fields
}

"""aggregate avg on columns"""
type payment_avg_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""
Boolean expression to filter rows from the table "payment". All fields are combined with a logical 'AND'.
"""
input payment_bool_exp {
  _and: [payment_bool_exp!]
  _not: payment_bool_exp
  _or: [payment_bool_exp!]
  amount: numeric_comparison_exp
  customer_id: smallint_comparison_exp
  payment_date: timestamp_comparison_exp
  payment_id: Int_comparison_exp
  rental_id: Int_comparison_exp
  staff_id: smallint_comparison_exp
}

"""
unique or primary key constraints on table "payment"
"""
enum payment_constraint {
  """unique or primary key constraint"""
  payment_pkey
}

"""
input type for incrementing numeric columns in table "payment"
"""
input payment_inc_input {
  amount: numeric
  customer_id: smallint
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""
input type for inserting data into table "payment"
"""
input payment_insert_input {
  amount: numeric
  customer_id: smallint
  payment_date: timestamp
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""aggregate max on columns"""
type payment_max_fields {
  amount: numeric
  customer_id: smallint
  payment_date: timestamp
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""aggregate min on columns"""
type payment_min_fields {
  amount: numeric
  customer_id: smallint
  payment_date: timestamp
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""
response of any mutation on the table "payment"
"""
type payment_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payment!]!
}

"""
on conflict condition type for table "payment"
"""
input payment_on_conflict {
  constraint: payment_constraint!
  update_columns: [payment_update_column!]! = []
  where: payment_bool_exp
}

"""Ordering options when selecting data from "payment"."""
input payment_order_by {
  amount: order_by
  customer_id: order_by
  payment_date: order_by
  payment_id: order_by
  rental_id: order_by
  staff_id: order_by
}

"""
columns and relationships of "payment_p2007_01"
"""
type payment_p2007_01 {
  amount: numeric!
  customer_id: smallint!
  payment_date: timestamp!
  payment_id: Int!
  rental_id: Int!
  staff_id: smallint!
}

"""
aggregated selection of "payment_p2007_01"
"""
type payment_p2007_01_aggregate {
  aggregate: payment_p2007_01_aggregate_fields
  nodes: [payment_p2007_01!]!
}

"""
aggregate fields of "payment_p2007_01"
"""
type payment_p2007_01_aggregate_fields {
  avg: payment_p2007_01_avg_fields
  count(columns: [payment_p2007_01_select_column!], distinct: Boolean): Int!
  max: payment_p2007_01_max_fields
  min: payment_p2007_01_min_fields
  stddev: payment_p2007_01_stddev_fields
  stddev_pop: payment_p2007_01_stddev_pop_fields
  stddev_samp: payment_p2007_01_stddev_samp_fields
  sum: payment_p2007_01_sum_fields
  var_pop: payment_p2007_01_var_pop_fields
  var_samp: payment_p2007_01_var_samp_fields
  variance: payment_p2007_01_variance_fields
}

"""aggregate avg on columns"""
type payment_p2007_01_avg_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""
Boolean expression to filter rows from the table "payment_p2007_01". All fields are combined with a logical 'AND'.
"""
input payment_p2007_01_bool_exp {
  _and: [payment_p2007_01_bool_exp!]
  _not: payment_p2007_01_bool_exp
  _or: [payment_p2007_01_bool_exp!]
  amount: numeric_comparison_exp
  customer_id: smallint_comparison_exp
  payment_date: timestamp_comparison_exp
  payment_id: Int_comparison_exp
  rental_id: Int_comparison_exp
  staff_id: smallint_comparison_exp
}

"""
input type for incrementing numeric columns in table "payment_p2007_01"
"""
input payment_p2007_01_inc_input {
  amount: numeric
  customer_id: smallint
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""
input type for inserting data into table "payment_p2007_01"
"""
input payment_p2007_01_insert_input {
  amount: numeric
  customer_id: smallint
  payment_date: timestamp
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""aggregate max on columns"""
type payment_p2007_01_max_fields {
  amount: numeric
  customer_id: smallint
  payment_date: timestamp
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""aggregate min on columns"""
type payment_p2007_01_min_fields {
  amount: numeric
  customer_id: smallint
  payment_date: timestamp
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""
response of any mutation on the table "payment_p2007_01"
"""
type payment_p2007_01_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payment_p2007_01!]!
}

"""Ordering options when selecting data from "payment_p2007_01"."""
input payment_p2007_01_order_by {
  amount: order_by
  customer_id: order_by
  payment_date: order_by
  payment_id: order_by
  rental_id: order_by
  staff_id: order_by
}

"""
select columns of table "payment_p2007_01"
"""
enum payment_p2007_01_select_column {
  """column name"""
  amount

  """column name"""
  customer_id

  """column name"""
  payment_date

  """column name"""
  payment_id

  """column name"""
  rental_id

  """column name"""
  staff_id
}

"""
input type for updating data in table "payment_p2007_01"
"""
input payment_p2007_01_set_input {
  amount: numeric
  customer_id: smallint
  payment_date: timestamp
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""aggregate stddev on columns"""
type payment_p2007_01_stddev_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate stddev_pop on columns"""
type payment_p2007_01_stddev_pop_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate stddev_samp on columns"""
type payment_p2007_01_stddev_samp_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate sum on columns"""
type payment_p2007_01_sum_fields {
  amount: numeric
  customer_id: smallint
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""aggregate var_pop on columns"""
type payment_p2007_01_var_pop_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate var_samp on columns"""
type payment_p2007_01_var_samp_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate variance on columns"""
type payment_p2007_01_variance_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""
columns and relationships of "payment_p2007_02"
"""
type payment_p2007_02 {
  amount: numeric!
  customer_id: smallint!
  payment_date: timestamp!
  payment_id: Int!
  rental_id: Int!
  staff_id: smallint!
}

"""
aggregated selection of "payment_p2007_02"
"""
type payment_p2007_02_aggregate {
  aggregate: payment_p2007_02_aggregate_fields
  nodes: [payment_p2007_02!]!
}

"""
aggregate fields of "payment_p2007_02"
"""
type payment_p2007_02_aggregate_fields {
  avg: payment_p2007_02_avg_fields
  count(columns: [payment_p2007_02_select_column!], distinct: Boolean): Int!
  max: payment_p2007_02_max_fields
  min: payment_p2007_02_min_fields
  stddev: payment_p2007_02_stddev_fields
  stddev_pop: payment_p2007_02_stddev_pop_fields
  stddev_samp: payment_p2007_02_stddev_samp_fields
  sum: payment_p2007_02_sum_fields
  var_pop: payment_p2007_02_var_pop_fields
  var_samp: payment_p2007_02_var_samp_fields
  variance: payment_p2007_02_variance_fields
}

"""aggregate avg on columns"""
type payment_p2007_02_avg_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""
Boolean expression to filter rows from the table "payment_p2007_02". All fields are combined with a logical 'AND'.
"""
input payment_p2007_02_bool_exp {
  _and: [payment_p2007_02_bool_exp!]
  _not: payment_p2007_02_bool_exp
  _or: [payment_p2007_02_bool_exp!]
  amount: numeric_comparison_exp
  customer_id: smallint_comparison_exp
  payment_date: timestamp_comparison_exp
  payment_id: Int_comparison_exp
  rental_id: Int_comparison_exp
  staff_id: smallint_comparison_exp
}

"""
input type for incrementing numeric columns in table "payment_p2007_02"
"""
input payment_p2007_02_inc_input {
  amount: numeric
  customer_id: smallint
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""
input type for inserting data into table "payment_p2007_02"
"""
input payment_p2007_02_insert_input {
  amount: numeric
  customer_id: smallint
  payment_date: timestamp
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""aggregate max on columns"""
type payment_p2007_02_max_fields {
  amount: numeric
  customer_id: smallint
  payment_date: timestamp
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""aggregate min on columns"""
type payment_p2007_02_min_fields {
  amount: numeric
  customer_id: smallint
  payment_date: timestamp
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""
response of any mutation on the table "payment_p2007_02"
"""
type payment_p2007_02_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payment_p2007_02!]!
}

"""Ordering options when selecting data from "payment_p2007_02"."""
input payment_p2007_02_order_by {
  amount: order_by
  customer_id: order_by
  payment_date: order_by
  payment_id: order_by
  rental_id: order_by
  staff_id: order_by
}

"""
select columns of table "payment_p2007_02"
"""
enum payment_p2007_02_select_column {
  """column name"""
  amount

  """column name"""
  customer_id

  """column name"""
  payment_date

  """column name"""
  payment_id

  """column name"""
  rental_id

  """column name"""
  staff_id
}

"""
input type for updating data in table "payment_p2007_02"
"""
input payment_p2007_02_set_input {
  amount: numeric
  customer_id: smallint
  payment_date: timestamp
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""aggregate stddev on columns"""
type payment_p2007_02_stddev_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate stddev_pop on columns"""
type payment_p2007_02_stddev_pop_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate stddev_samp on columns"""
type payment_p2007_02_stddev_samp_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate sum on columns"""
type payment_p2007_02_sum_fields {
  amount: numeric
  customer_id: smallint
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""aggregate var_pop on columns"""
type payment_p2007_02_var_pop_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate var_samp on columns"""
type payment_p2007_02_var_samp_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate variance on columns"""
type payment_p2007_02_variance_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""
columns and relationships of "payment_p2007_03"
"""
type payment_p2007_03 {
  amount: numeric!
  customer_id: smallint!
  payment_date: timestamp!
  payment_id: Int!
  rental_id: Int!
  staff_id: smallint!
}

"""
aggregated selection of "payment_p2007_03"
"""
type payment_p2007_03_aggregate {
  aggregate: payment_p2007_03_aggregate_fields
  nodes: [payment_p2007_03!]!
}

"""
aggregate fields of "payment_p2007_03"
"""
type payment_p2007_03_aggregate_fields {
  avg: payment_p2007_03_avg_fields
  count(columns: [payment_p2007_03_select_column!], distinct: Boolean): Int!
  max: payment_p2007_03_max_fields
  min: payment_p2007_03_min_fields
  stddev: payment_p2007_03_stddev_fields
  stddev_pop: payment_p2007_03_stddev_pop_fields
  stddev_samp: payment_p2007_03_stddev_samp_fields
  sum: payment_p2007_03_sum_fields
  var_pop: payment_p2007_03_var_pop_fields
  var_samp: payment_p2007_03_var_samp_fields
  variance: payment_p2007_03_variance_fields
}

"""aggregate avg on columns"""
type payment_p2007_03_avg_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""
Boolean expression to filter rows from the table "payment_p2007_03". All fields are combined with a logical 'AND'.
"""
input payment_p2007_03_bool_exp {
  _and: [payment_p2007_03_bool_exp!]
  _not: payment_p2007_03_bool_exp
  _or: [payment_p2007_03_bool_exp!]
  amount: numeric_comparison_exp
  customer_id: smallint_comparison_exp
  payment_date: timestamp_comparison_exp
  payment_id: Int_comparison_exp
  rental_id: Int_comparison_exp
  staff_id: smallint_comparison_exp
}

"""
input type for incrementing numeric columns in table "payment_p2007_03"
"""
input payment_p2007_03_inc_input {
  amount: numeric
  customer_id: smallint
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""
input type for inserting data into table "payment_p2007_03"
"""
input payment_p2007_03_insert_input {
  amount: numeric
  customer_id: smallint
  payment_date: timestamp
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""aggregate max on columns"""
type payment_p2007_03_max_fields {
  amount: numeric
  customer_id: smallint
  payment_date: timestamp
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""aggregate min on columns"""
type payment_p2007_03_min_fields {
  amount: numeric
  customer_id: smallint
  payment_date: timestamp
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""
response of any mutation on the table "payment_p2007_03"
"""
type payment_p2007_03_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payment_p2007_03!]!
}

"""Ordering options when selecting data from "payment_p2007_03"."""
input payment_p2007_03_order_by {
  amount: order_by
  customer_id: order_by
  payment_date: order_by
  payment_id: order_by
  rental_id: order_by
  staff_id: order_by
}

"""
select columns of table "payment_p2007_03"
"""
enum payment_p2007_03_select_column {
  """column name"""
  amount

  """column name"""
  customer_id

  """column name"""
  payment_date

  """column name"""
  payment_id

  """column name"""
  rental_id

  """column name"""
  staff_id
}

"""
input type for updating data in table "payment_p2007_03"
"""
input payment_p2007_03_set_input {
  amount: numeric
  customer_id: smallint
  payment_date: timestamp
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""aggregate stddev on columns"""
type payment_p2007_03_stddev_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate stddev_pop on columns"""
type payment_p2007_03_stddev_pop_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate stddev_samp on columns"""
type payment_p2007_03_stddev_samp_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate sum on columns"""
type payment_p2007_03_sum_fields {
  amount: numeric
  customer_id: smallint
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""aggregate var_pop on columns"""
type payment_p2007_03_var_pop_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate var_samp on columns"""
type payment_p2007_03_var_samp_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate variance on columns"""
type payment_p2007_03_variance_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""
columns and relationships of "payment_p2007_04"
"""
type payment_p2007_04 {
  amount: numeric!
  customer_id: smallint!
  payment_date: timestamp!
  payment_id: Int!
  rental_id: Int!
  staff_id: smallint!
}

"""
aggregated selection of "payment_p2007_04"
"""
type payment_p2007_04_aggregate {
  aggregate: payment_p2007_04_aggregate_fields
  nodes: [payment_p2007_04!]!
}

"""
aggregate fields of "payment_p2007_04"
"""
type payment_p2007_04_aggregate_fields {
  avg: payment_p2007_04_avg_fields
  count(columns: [payment_p2007_04_select_column!], distinct: Boolean): Int!
  max: payment_p2007_04_max_fields
  min: payment_p2007_04_min_fields
  stddev: payment_p2007_04_stddev_fields
  stddev_pop: payment_p2007_04_stddev_pop_fields
  stddev_samp: payment_p2007_04_stddev_samp_fields
  sum: payment_p2007_04_sum_fields
  var_pop: payment_p2007_04_var_pop_fields
  var_samp: payment_p2007_04_var_samp_fields
  variance: payment_p2007_04_variance_fields
}

"""aggregate avg on columns"""
type payment_p2007_04_avg_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""
Boolean expression to filter rows from the table "payment_p2007_04". All fields are combined with a logical 'AND'.
"""
input payment_p2007_04_bool_exp {
  _and: [payment_p2007_04_bool_exp!]
  _not: payment_p2007_04_bool_exp
  _or: [payment_p2007_04_bool_exp!]
  amount: numeric_comparison_exp
  customer_id: smallint_comparison_exp
  payment_date: timestamp_comparison_exp
  payment_id: Int_comparison_exp
  rental_id: Int_comparison_exp
  staff_id: smallint_comparison_exp
}

"""
input type for incrementing numeric columns in table "payment_p2007_04"
"""
input payment_p2007_04_inc_input {
  amount: numeric
  customer_id: smallint
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""
input type for inserting data into table "payment_p2007_04"
"""
input payment_p2007_04_insert_input {
  amount: numeric
  customer_id: smallint
  payment_date: timestamp
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""aggregate max on columns"""
type payment_p2007_04_max_fields {
  amount: numeric
  customer_id: smallint
  payment_date: timestamp
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""aggregate min on columns"""
type payment_p2007_04_min_fields {
  amount: numeric
  customer_id: smallint
  payment_date: timestamp
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""
response of any mutation on the table "payment_p2007_04"
"""
type payment_p2007_04_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payment_p2007_04!]!
}

"""Ordering options when selecting data from "payment_p2007_04"."""
input payment_p2007_04_order_by {
  amount: order_by
  customer_id: order_by
  payment_date: order_by
  payment_id: order_by
  rental_id: order_by
  staff_id: order_by
}

"""
select columns of table "payment_p2007_04"
"""
enum payment_p2007_04_select_column {
  """column name"""
  amount

  """column name"""
  customer_id

  """column name"""
  payment_date

  """column name"""
  payment_id

  """column name"""
  rental_id

  """column name"""
  staff_id
}

"""
input type for updating data in table "payment_p2007_04"
"""
input payment_p2007_04_set_input {
  amount: numeric
  customer_id: smallint
  payment_date: timestamp
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""aggregate stddev on columns"""
type payment_p2007_04_stddev_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate stddev_pop on columns"""
type payment_p2007_04_stddev_pop_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate stddev_samp on columns"""
type payment_p2007_04_stddev_samp_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate sum on columns"""
type payment_p2007_04_sum_fields {
  amount: numeric
  customer_id: smallint
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""aggregate var_pop on columns"""
type payment_p2007_04_var_pop_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate var_samp on columns"""
type payment_p2007_04_var_samp_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate variance on columns"""
type payment_p2007_04_variance_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""
columns and relationships of "payment_p2007_05"
"""
type payment_p2007_05 {
  amount: numeric!
  customer_id: smallint!
  payment_date: timestamp!
  payment_id: Int!
  rental_id: Int!
  staff_id: smallint!
}

"""
aggregated selection of "payment_p2007_05"
"""
type payment_p2007_05_aggregate {
  aggregate: payment_p2007_05_aggregate_fields
  nodes: [payment_p2007_05!]!
}

"""
aggregate fields of "payment_p2007_05"
"""
type payment_p2007_05_aggregate_fields {
  avg: payment_p2007_05_avg_fields
  count(columns: [payment_p2007_05_select_column!], distinct: Boolean): Int!
  max: payment_p2007_05_max_fields
  min: payment_p2007_05_min_fields
  stddev: payment_p2007_05_stddev_fields
  stddev_pop: payment_p2007_05_stddev_pop_fields
  stddev_samp: payment_p2007_05_stddev_samp_fields
  sum: payment_p2007_05_sum_fields
  var_pop: payment_p2007_05_var_pop_fields
  var_samp: payment_p2007_05_var_samp_fields
  variance: payment_p2007_05_variance_fields
}

"""aggregate avg on columns"""
type payment_p2007_05_avg_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""
Boolean expression to filter rows from the table "payment_p2007_05". All fields are combined with a logical 'AND'.
"""
input payment_p2007_05_bool_exp {
  _and: [payment_p2007_05_bool_exp!]
  _not: payment_p2007_05_bool_exp
  _or: [payment_p2007_05_bool_exp!]
  amount: numeric_comparison_exp
  customer_id: smallint_comparison_exp
  payment_date: timestamp_comparison_exp
  payment_id: Int_comparison_exp
  rental_id: Int_comparison_exp
  staff_id: smallint_comparison_exp
}

"""
input type for incrementing numeric columns in table "payment_p2007_05"
"""
input payment_p2007_05_inc_input {
  amount: numeric
  customer_id: smallint
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""
input type for inserting data into table "payment_p2007_05"
"""
input payment_p2007_05_insert_input {
  amount: numeric
  customer_id: smallint
  payment_date: timestamp
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""aggregate max on columns"""
type payment_p2007_05_max_fields {
  amount: numeric
  customer_id: smallint
  payment_date: timestamp
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""aggregate min on columns"""
type payment_p2007_05_min_fields {
  amount: numeric
  customer_id: smallint
  payment_date: timestamp
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""
response of any mutation on the table "payment_p2007_05"
"""
type payment_p2007_05_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payment_p2007_05!]!
}

"""Ordering options when selecting data from "payment_p2007_05"."""
input payment_p2007_05_order_by {
  amount: order_by
  customer_id: order_by
  payment_date: order_by
  payment_id: order_by
  rental_id: order_by
  staff_id: order_by
}

"""
select columns of table "payment_p2007_05"
"""
enum payment_p2007_05_select_column {
  """column name"""
  amount

  """column name"""
  customer_id

  """column name"""
  payment_date

  """column name"""
  payment_id

  """column name"""
  rental_id

  """column name"""
  staff_id
}

"""
input type for updating data in table "payment_p2007_05"
"""
input payment_p2007_05_set_input {
  amount: numeric
  customer_id: smallint
  payment_date: timestamp
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""aggregate stddev on columns"""
type payment_p2007_05_stddev_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate stddev_pop on columns"""
type payment_p2007_05_stddev_pop_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate stddev_samp on columns"""
type payment_p2007_05_stddev_samp_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate sum on columns"""
type payment_p2007_05_sum_fields {
  amount: numeric
  customer_id: smallint
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""aggregate var_pop on columns"""
type payment_p2007_05_var_pop_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate var_samp on columns"""
type payment_p2007_05_var_samp_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate variance on columns"""
type payment_p2007_05_variance_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""
columns and relationships of "payment_p2007_06"
"""
type payment_p2007_06 {
  amount: numeric!
  customer_id: smallint!
  payment_date: timestamp!
  payment_id: Int!
  rental_id: Int!
  staff_id: smallint!
}

"""
aggregated selection of "payment_p2007_06"
"""
type payment_p2007_06_aggregate {
  aggregate: payment_p2007_06_aggregate_fields
  nodes: [payment_p2007_06!]!
}

"""
aggregate fields of "payment_p2007_06"
"""
type payment_p2007_06_aggregate_fields {
  avg: payment_p2007_06_avg_fields
  count(columns: [payment_p2007_06_select_column!], distinct: Boolean): Int!
  max: payment_p2007_06_max_fields
  min: payment_p2007_06_min_fields
  stddev: payment_p2007_06_stddev_fields
  stddev_pop: payment_p2007_06_stddev_pop_fields
  stddev_samp: payment_p2007_06_stddev_samp_fields
  sum: payment_p2007_06_sum_fields
  var_pop: payment_p2007_06_var_pop_fields
  var_samp: payment_p2007_06_var_samp_fields
  variance: payment_p2007_06_variance_fields
}

"""aggregate avg on columns"""
type payment_p2007_06_avg_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""
Boolean expression to filter rows from the table "payment_p2007_06". All fields are combined with a logical 'AND'.
"""
input payment_p2007_06_bool_exp {
  _and: [payment_p2007_06_bool_exp!]
  _not: payment_p2007_06_bool_exp
  _or: [payment_p2007_06_bool_exp!]
  amount: numeric_comparison_exp
  customer_id: smallint_comparison_exp
  payment_date: timestamp_comparison_exp
  payment_id: Int_comparison_exp
  rental_id: Int_comparison_exp
  staff_id: smallint_comparison_exp
}

"""
input type for incrementing numeric columns in table "payment_p2007_06"
"""
input payment_p2007_06_inc_input {
  amount: numeric
  customer_id: smallint
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""
input type for inserting data into table "payment_p2007_06"
"""
input payment_p2007_06_insert_input {
  amount: numeric
  customer_id: smallint
  payment_date: timestamp
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""aggregate max on columns"""
type payment_p2007_06_max_fields {
  amount: numeric
  customer_id: smallint
  payment_date: timestamp
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""aggregate min on columns"""
type payment_p2007_06_min_fields {
  amount: numeric
  customer_id: smallint
  payment_date: timestamp
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""
response of any mutation on the table "payment_p2007_06"
"""
type payment_p2007_06_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payment_p2007_06!]!
}

"""Ordering options when selecting data from "payment_p2007_06"."""
input payment_p2007_06_order_by {
  amount: order_by
  customer_id: order_by
  payment_date: order_by
  payment_id: order_by
  rental_id: order_by
  staff_id: order_by
}

"""
select columns of table "payment_p2007_06"
"""
enum payment_p2007_06_select_column {
  """column name"""
  amount

  """column name"""
  customer_id

  """column name"""
  payment_date

  """column name"""
  payment_id

  """column name"""
  rental_id

  """column name"""
  staff_id
}

"""
input type for updating data in table "payment_p2007_06"
"""
input payment_p2007_06_set_input {
  amount: numeric
  customer_id: smallint
  payment_date: timestamp
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""aggregate stddev on columns"""
type payment_p2007_06_stddev_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate stddev_pop on columns"""
type payment_p2007_06_stddev_pop_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate stddev_samp on columns"""
type payment_p2007_06_stddev_samp_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate sum on columns"""
type payment_p2007_06_sum_fields {
  amount: numeric
  customer_id: smallint
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""aggregate var_pop on columns"""
type payment_p2007_06_var_pop_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate var_samp on columns"""
type payment_p2007_06_var_samp_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate variance on columns"""
type payment_p2007_06_variance_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""primary key columns input for table: payment"""
input payment_pk_columns_input {
  payment_id: Int!
}

"""
select columns of table "payment"
"""
enum payment_select_column {
  """column name"""
  amount

  """column name"""
  customer_id

  """column name"""
  payment_date

  """column name"""
  payment_id

  """column name"""
  rental_id

  """column name"""
  staff_id
}

"""
input type for updating data in table "payment"
"""
input payment_set_input {
  amount: numeric
  customer_id: smallint
  payment_date: timestamp
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""aggregate stddev on columns"""
type payment_stddev_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate stddev_pop on columns"""
type payment_stddev_pop_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate stddev_samp on columns"""
type payment_stddev_samp_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate sum on columns"""
type payment_sum_fields {
  amount: numeric
  customer_id: smallint
  payment_id: Int
  rental_id: Int
  staff_id: smallint
}

"""
update columns of table "payment"
"""
enum payment_update_column {
  """column name"""
  amount

  """column name"""
  customer_id

  """column name"""
  payment_date

  """column name"""
  payment_id

  """column name"""
  rental_id

  """column name"""
  staff_id
}

"""aggregate var_pop on columns"""
type payment_var_pop_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate var_samp on columns"""
type payment_var_samp_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate variance on columns"""
type payment_variance_fields {
  amount: Float
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

type query_root {
  """
  fetch data from the table: "actor"
  """
  actor(
    """distinct select on columns"""
    distinct_on: [actor_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [actor_order_by!]

    """filter the rows returned"""
    where: actor_bool_exp
  ): [actor!]!

  """
  fetch aggregated fields from the table: "actor"
  """
  actor_aggregate(
    """distinct select on columns"""
    distinct_on: [actor_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [actor_order_by!]

    """filter the rows returned"""
    where: actor_bool_exp
  ): actor_aggregate!

  """fetch data from the table: "actor" using primary key columns"""
  actor_by_pk(actor_id: Int!): actor

  """
  fetch data from the table: "actor_info"
  """
  actor_info(
    """distinct select on columns"""
    distinct_on: [actor_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [actor_info_order_by!]

    """filter the rows returned"""
    where: actor_info_bool_exp
  ): [actor_info!]!

  """
  fetch aggregated fields from the table: "actor_info"
  """
  actor_info_aggregate(
    """distinct select on columns"""
    distinct_on: [actor_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [actor_info_order_by!]

    """filter the rows returned"""
    where: actor_info_bool_exp
  ): actor_info_aggregate!

  """
  fetch data from the table: "address"
  """
  address(
    """distinct select on columns"""
    distinct_on: [address_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [address_order_by!]

    """filter the rows returned"""
    where: address_bool_exp
  ): [address!]!

  """
  fetch aggregated fields from the table: "address"
  """
  address_aggregate(
    """distinct select on columns"""
    distinct_on: [address_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [address_order_by!]

    """filter the rows returned"""
    where: address_bool_exp
  ): address_aggregate!

  """fetch data from the table: "address" using primary key columns"""
  address_by_pk(address_id: Int!): address

  """
  fetch data from the table: "category"
  """
  category(
    """distinct select on columns"""
    distinct_on: [category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [category_order_by!]

    """filter the rows returned"""
    where: category_bool_exp
  ): [category!]!

  """
  fetch aggregated fields from the table: "category"
  """
  category_aggregate(
    """distinct select on columns"""
    distinct_on: [category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [category_order_by!]

    """filter the rows returned"""
    where: category_bool_exp
  ): category_aggregate!

  """fetch data from the table: "category" using primary key columns"""
  category_by_pk(category_id: Int!): category

  """
  fetch data from the table: "city"
  """
  city(
    """distinct select on columns"""
    distinct_on: [city_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [city_order_by!]

    """filter the rows returned"""
    where: city_bool_exp
  ): [city!]!

  """
  fetch aggregated fields from the table: "city"
  """
  city_aggregate(
    """distinct select on columns"""
    distinct_on: [city_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [city_order_by!]

    """filter the rows returned"""
    where: city_bool_exp
  ): city_aggregate!

  """fetch data from the table: "city" using primary key columns"""
  city_by_pk(city_id: Int!): city

  """
  fetch data from the table: "country"
  """
  country(
    """distinct select on columns"""
    distinct_on: [country_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [country_order_by!]

    """filter the rows returned"""
    where: country_bool_exp
  ): [country!]!

  """
  fetch aggregated fields from the table: "country"
  """
  country_aggregate(
    """distinct select on columns"""
    distinct_on: [country_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [country_order_by!]

    """filter the rows returned"""
    where: country_bool_exp
  ): country_aggregate!

  """fetch data from the table: "country" using primary key columns"""
  country_by_pk(country_id: Int!): country

  """
  fetch data from the table: "customer"
  """
  customer(
    """distinct select on columns"""
    distinct_on: [customer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_order_by!]

    """filter the rows returned"""
    where: customer_bool_exp
  ): [customer!]!

  """
  fetch aggregated fields from the table: "customer"
  """
  customer_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_order_by!]

    """filter the rows returned"""
    where: customer_bool_exp
  ): customer_aggregate!

  """fetch data from the table: "customer" using primary key columns"""
  customer_by_pk(customer_id: Int!): customer

  """
  fetch data from the table: "customer_list"
  """
  customer_list(
    """distinct select on columns"""
    distinct_on: [customer_list_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_list_order_by!]

    """filter the rows returned"""
    where: customer_list_bool_exp
  ): [customer_list!]!

  """
  fetch aggregated fields from the table: "customer_list"
  """
  customer_list_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_list_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_list_order_by!]

    """filter the rows returned"""
    where: customer_list_bool_exp
  ): customer_list_aggregate!

  """
  fetch data from the table: "film"
  """
  film(
    """distinct select on columns"""
    distinct_on: [film_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [film_order_by!]

    """filter the rows returned"""
    where: film_bool_exp
  ): [film!]!

  """
  fetch data from the table: "film_actor"
  """
  film_actor(
    """distinct select on columns"""
    distinct_on: [film_actor_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [film_actor_order_by!]

    """filter the rows returned"""
    where: film_actor_bool_exp
  ): [film_actor!]!

  """
  fetch aggregated fields from the table: "film_actor"
  """
  film_actor_aggregate(
    """distinct select on columns"""
    distinct_on: [film_actor_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [film_actor_order_by!]

    """filter the rows returned"""
    where: film_actor_bool_exp
  ): film_actor_aggregate!

  """fetch data from the table: "film_actor" using primary key columns"""
  film_actor_by_pk(actor_id: smallint!, film_id: smallint!): film_actor

  """
  fetch aggregated fields from the table: "film"
  """
  film_aggregate(
    """distinct select on columns"""
    distinct_on: [film_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [film_order_by!]

    """filter the rows returned"""
    where: film_bool_exp
  ): film_aggregate!

  """fetch data from the table: "film" using primary key columns"""
  film_by_pk(film_id: Int!): film

  """
  fetch data from the table: "film_category"
  """
  film_category(
    """distinct select on columns"""
    distinct_on: [film_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [film_category_order_by!]

    """filter the rows returned"""
    where: film_category_bool_exp
  ): [film_category!]!

  """
  fetch aggregated fields from the table: "film_category"
  """
  film_category_aggregate(
    """distinct select on columns"""
    distinct_on: [film_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [film_category_order_by!]

    """filter the rows returned"""
    where: film_category_bool_exp
  ): film_category_aggregate!

  """fetch data from the table: "film_category" using primary key columns"""
  film_category_by_pk(category_id: smallint!, film_id: smallint!): film_category

  """
  fetch data from the table: "film_list"
  """
  film_list(
    """distinct select on columns"""
    distinct_on: [film_list_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [film_list_order_by!]

    """filter the rows returned"""
    where: film_list_bool_exp
  ): [film_list!]!

  """
  fetch aggregated fields from the table: "film_list"
  """
  film_list_aggregate(
    """distinct select on columns"""
    distinct_on: [film_list_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [film_list_order_by!]

    """filter the rows returned"""
    where: film_list_bool_exp
  ): film_list_aggregate!

  """
  fetch data from the table: "inventory"
  """
  inventory(
    """distinct select on columns"""
    distinct_on: [inventory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [inventory_order_by!]

    """filter the rows returned"""
    where: inventory_bool_exp
  ): [inventory!]!

  """
  fetch aggregated fields from the table: "inventory"
  """
  inventory_aggregate(
    """distinct select on columns"""
    distinct_on: [inventory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [inventory_order_by!]

    """filter the rows returned"""
    where: inventory_bool_exp
  ): inventory_aggregate!

  """fetch data from the table: "inventory" using primary key columns"""
  inventory_by_pk(inventory_id: Int!): inventory

  """
  fetch data from the table: "language"
  """
  language(
    """distinct select on columns"""
    distinct_on: [language_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [language_order_by!]

    """filter the rows returned"""
    where: language_bool_exp
  ): [language!]!

  """
  fetch aggregated fields from the table: "language"
  """
  language_aggregate(
    """distinct select on columns"""
    distinct_on: [language_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [language_order_by!]

    """filter the rows returned"""
    where: language_bool_exp
  ): language_aggregate!

  """fetch data from the table: "language" using primary key columns"""
  language_by_pk(language_id: Int!): language

  """
  fetch data from the table: "nicer_but_slower_film_list"
  """
  nicer_but_slower_film_list(
    """distinct select on columns"""
    distinct_on: [nicer_but_slower_film_list_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [nicer_but_slower_film_list_order_by!]

    """filter the rows returned"""
    where: nicer_but_slower_film_list_bool_exp
  ): [nicer_but_slower_film_list!]!

  """
  fetch aggregated fields from the table: "nicer_but_slower_film_list"
  """
  nicer_but_slower_film_list_aggregate(
    """distinct select on columns"""
    distinct_on: [nicer_but_slower_film_list_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [nicer_but_slower_film_list_order_by!]

    """filter the rows returned"""
    where: nicer_but_slower_film_list_bool_exp
  ): nicer_but_slower_film_list_aggregate!

  """
  fetch data from the table: "payment"
  """
  payment(
    """distinct select on columns"""
    distinct_on: [payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_order_by!]

    """filter the rows returned"""
    where: payment_bool_exp
  ): [payment!]!

  """
  fetch aggregated fields from the table: "payment"
  """
  payment_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_order_by!]

    """filter the rows returned"""
    where: payment_bool_exp
  ): payment_aggregate!

  """fetch data from the table: "payment" using primary key columns"""
  payment_by_pk(payment_id: Int!): payment

  """
  fetch data from the table: "payment_p2007_01"
  """
  payment_p2007_01(
    """distinct select on columns"""
    distinct_on: [payment_p2007_01_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_p2007_01_order_by!]

    """filter the rows returned"""
    where: payment_p2007_01_bool_exp
  ): [payment_p2007_01!]!

  """
  fetch aggregated fields from the table: "payment_p2007_01"
  """
  payment_p2007_01_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_p2007_01_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_p2007_01_order_by!]

    """filter the rows returned"""
    where: payment_p2007_01_bool_exp
  ): payment_p2007_01_aggregate!

  """
  fetch data from the table: "payment_p2007_02"
  """
  payment_p2007_02(
    """distinct select on columns"""
    distinct_on: [payment_p2007_02_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_p2007_02_order_by!]

    """filter the rows returned"""
    where: payment_p2007_02_bool_exp
  ): [payment_p2007_02!]!

  """
  fetch aggregated fields from the table: "payment_p2007_02"
  """
  payment_p2007_02_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_p2007_02_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_p2007_02_order_by!]

    """filter the rows returned"""
    where: payment_p2007_02_bool_exp
  ): payment_p2007_02_aggregate!

  """
  fetch data from the table: "payment_p2007_03"
  """
  payment_p2007_03(
    """distinct select on columns"""
    distinct_on: [payment_p2007_03_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_p2007_03_order_by!]

    """filter the rows returned"""
    where: payment_p2007_03_bool_exp
  ): [payment_p2007_03!]!

  """
  fetch aggregated fields from the table: "payment_p2007_03"
  """
  payment_p2007_03_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_p2007_03_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_p2007_03_order_by!]

    """filter the rows returned"""
    where: payment_p2007_03_bool_exp
  ): payment_p2007_03_aggregate!

  """
  fetch data from the table: "payment_p2007_04"
  """
  payment_p2007_04(
    """distinct select on columns"""
    distinct_on: [payment_p2007_04_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_p2007_04_order_by!]

    """filter the rows returned"""
    where: payment_p2007_04_bool_exp
  ): [payment_p2007_04!]!

  """
  fetch aggregated fields from the table: "payment_p2007_04"
  """
  payment_p2007_04_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_p2007_04_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_p2007_04_order_by!]

    """filter the rows returned"""
    where: payment_p2007_04_bool_exp
  ): payment_p2007_04_aggregate!

  """
  fetch data from the table: "payment_p2007_05"
  """
  payment_p2007_05(
    """distinct select on columns"""
    distinct_on: [payment_p2007_05_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_p2007_05_order_by!]

    """filter the rows returned"""
    where: payment_p2007_05_bool_exp
  ): [payment_p2007_05!]!

  """
  fetch aggregated fields from the table: "payment_p2007_05"
  """
  payment_p2007_05_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_p2007_05_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_p2007_05_order_by!]

    """filter the rows returned"""
    where: payment_p2007_05_bool_exp
  ): payment_p2007_05_aggregate!

  """
  fetch data from the table: "payment_p2007_06"
  """
  payment_p2007_06(
    """distinct select on columns"""
    distinct_on: [payment_p2007_06_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_p2007_06_order_by!]

    """filter the rows returned"""
    where: payment_p2007_06_bool_exp
  ): [payment_p2007_06!]!

  """
  fetch aggregated fields from the table: "payment_p2007_06"
  """
  payment_p2007_06_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_p2007_06_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_p2007_06_order_by!]

    """filter the rows returned"""
    where: payment_p2007_06_bool_exp
  ): payment_p2007_06_aggregate!

  """
  fetch data from the table: "rental"
  """
  rental(
    """distinct select on columns"""
    distinct_on: [rental_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rental_order_by!]

    """filter the rows returned"""
    where: rental_bool_exp
  ): [rental!]!

  """
  fetch aggregated fields from the table: "rental"
  """
  rental_aggregate(
    """distinct select on columns"""
    distinct_on: [rental_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rental_order_by!]

    """filter the rows returned"""
    where: rental_bool_exp
  ): rental_aggregate!

  """fetch data from the table: "rental" using primary key columns"""
  rental_by_pk(rental_id: Int!): rental

  """
  fetch data from the table: "sales_by_film_category"
  """
  sales_by_film_category(
    """distinct select on columns"""
    distinct_on: [sales_by_film_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sales_by_film_category_order_by!]

    """filter the rows returned"""
    where: sales_by_film_category_bool_exp
  ): [sales_by_film_category!]!

  """
  fetch aggregated fields from the table: "sales_by_film_category"
  """
  sales_by_film_category_aggregate(
    """distinct select on columns"""
    distinct_on: [sales_by_film_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sales_by_film_category_order_by!]

    """filter the rows returned"""
    where: sales_by_film_category_bool_exp
  ): sales_by_film_category_aggregate!

  """
  fetch data from the table: "sales_by_store"
  """
  sales_by_store(
    """distinct select on columns"""
    distinct_on: [sales_by_store_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sales_by_store_order_by!]

    """filter the rows returned"""
    where: sales_by_store_bool_exp
  ): [sales_by_store!]!

  """
  fetch aggregated fields from the table: "sales_by_store"
  """
  sales_by_store_aggregate(
    """distinct select on columns"""
    distinct_on: [sales_by_store_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sales_by_store_order_by!]

    """filter the rows returned"""
    where: sales_by_store_bool_exp
  ): sales_by_store_aggregate!

  """
  fetch data from the table: "staff"
  """
  staff(
    """distinct select on columns"""
    distinct_on: [staff_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [staff_order_by!]

    """filter the rows returned"""
    where: staff_bool_exp
  ): [staff!]!

  """
  fetch aggregated fields from the table: "staff"
  """
  staff_aggregate(
    """distinct select on columns"""
    distinct_on: [staff_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [staff_order_by!]

    """filter the rows returned"""
    where: staff_bool_exp
  ): staff_aggregate!

  """fetch data from the table: "staff" using primary key columns"""
  staff_by_pk(staff_id: Int!): staff

  """
  fetch data from the table: "staff_list"
  """
  staff_list(
    """distinct select on columns"""
    distinct_on: [staff_list_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [staff_list_order_by!]

    """filter the rows returned"""
    where: staff_list_bool_exp
  ): [staff_list!]!

  """
  fetch aggregated fields from the table: "staff_list"
  """
  staff_list_aggregate(
    """distinct select on columns"""
    distinct_on: [staff_list_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [staff_list_order_by!]

    """filter the rows returned"""
    where: staff_list_bool_exp
  ): staff_list_aggregate!

  """
  fetch data from the table: "store"
  """
  store(
    """distinct select on columns"""
    distinct_on: [store_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [store_order_by!]

    """filter the rows returned"""
    where: store_bool_exp
  ): [store!]!

  """
  fetch aggregated fields from the table: "store"
  """
  store_aggregate(
    """distinct select on columns"""
    distinct_on: [store_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [store_order_by!]

    """filter the rows returned"""
    where: store_bool_exp
  ): store_aggregate!

  """fetch data from the table: "store" using primary key columns"""
  store_by_pk(store_id: Int!): store
}

"""
columns and relationships of "rental"
"""
type rental {
  customer_id: smallint!
  inventory_id: Int!
  last_update: timestamp!
  rental_date: timestamp!
  rental_id: Int!
  return_date: timestamp
  staff_id: smallint!
}

"""
aggregated selection of "rental"
"""
type rental_aggregate {
  aggregate: rental_aggregate_fields
  nodes: [rental!]!
}

"""
aggregate fields of "rental"
"""
type rental_aggregate_fields {
  avg: rental_avg_fields
  count(columns: [rental_select_column!], distinct: Boolean): Int!
  max: rental_max_fields
  min: rental_min_fields
  stddev: rental_stddev_fields
  stddev_pop: rental_stddev_pop_fields
  stddev_samp: rental_stddev_samp_fields
  sum: rental_sum_fields
  var_pop: rental_var_pop_fields
  var_samp: rental_var_samp_fields
  variance: rental_variance_fields
}

"""aggregate avg on columns"""
type rental_avg_fields {
  customer_id: Float
  inventory_id: Float
  rental_id: Float
  staff_id: Float
}

"""
Boolean expression to filter rows from the table "rental". All fields are combined with a logical 'AND'.
"""
input rental_bool_exp {
  _and: [rental_bool_exp!]
  _not: rental_bool_exp
  _or: [rental_bool_exp!]
  customer_id: smallint_comparison_exp
  inventory_id: Int_comparison_exp
  last_update: timestamp_comparison_exp
  rental_date: timestamp_comparison_exp
  rental_id: Int_comparison_exp
  return_date: timestamp_comparison_exp
  staff_id: smallint_comparison_exp
}

"""
unique or primary key constraints on table "rental"
"""
enum rental_constraint {
  """unique or primary key constraint"""
  idx_unq_rental_rental_date_inventory_id_customer_id

  """unique or primary key constraint"""
  rental_pkey
}

"""
input type for incrementing numeric columns in table "rental"
"""
input rental_inc_input {
  customer_id: smallint
  inventory_id: Int
  rental_id: Int
  staff_id: smallint
}

"""
input type for inserting data into table "rental"
"""
input rental_insert_input {
  customer_id: smallint
  inventory_id: Int
  last_update: timestamp
  rental_date: timestamp
  rental_id: Int
  return_date: timestamp
  staff_id: smallint
}

"""aggregate max on columns"""
type rental_max_fields {
  customer_id: smallint
  inventory_id: Int
  last_update: timestamp
  rental_date: timestamp
  rental_id: Int
  return_date: timestamp
  staff_id: smallint
}

"""aggregate min on columns"""
type rental_min_fields {
  customer_id: smallint
  inventory_id: Int
  last_update: timestamp
  rental_date: timestamp
  rental_id: Int
  return_date: timestamp
  staff_id: smallint
}

"""
response of any mutation on the table "rental"
"""
type rental_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rental!]!
}

"""
on conflict condition type for table "rental"
"""
input rental_on_conflict {
  constraint: rental_constraint!
  update_columns: [rental_update_column!]! = []
  where: rental_bool_exp
}

"""Ordering options when selecting data from "rental"."""
input rental_order_by {
  customer_id: order_by
  inventory_id: order_by
  last_update: order_by
  rental_date: order_by
  rental_id: order_by
  return_date: order_by
  staff_id: order_by
}

"""primary key columns input for table: rental"""
input rental_pk_columns_input {
  rental_id: Int!
}

"""
select columns of table "rental"
"""
enum rental_select_column {
  """column name"""
  customer_id

  """column name"""
  inventory_id

  """column name"""
  last_update

  """column name"""
  rental_date

  """column name"""
  rental_id

  """column name"""
  return_date

  """column name"""
  staff_id
}

"""
input type for updating data in table "rental"
"""
input rental_set_input {
  customer_id: smallint
  inventory_id: Int
  last_update: timestamp
  rental_date: timestamp
  rental_id: Int
  return_date: timestamp
  staff_id: smallint
}

"""aggregate stddev on columns"""
type rental_stddev_fields {
  customer_id: Float
  inventory_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate stddev_pop on columns"""
type rental_stddev_pop_fields {
  customer_id: Float
  inventory_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate stddev_samp on columns"""
type rental_stddev_samp_fields {
  customer_id: Float
  inventory_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate sum on columns"""
type rental_sum_fields {
  customer_id: smallint
  inventory_id: Int
  rental_id: Int
  staff_id: smallint
}

"""
update columns of table "rental"
"""
enum rental_update_column {
  """column name"""
  customer_id

  """column name"""
  inventory_id

  """column name"""
  last_update

  """column name"""
  rental_date

  """column name"""
  rental_id

  """column name"""
  return_date

  """column name"""
  staff_id
}

"""aggregate var_pop on columns"""
type rental_var_pop_fields {
  customer_id: Float
  inventory_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate var_samp on columns"""
type rental_var_samp_fields {
  customer_id: Float
  inventory_id: Float
  rental_id: Float
  staff_id: Float
}

"""aggregate variance on columns"""
type rental_variance_fields {
  customer_id: Float
  inventory_id: Float
  rental_id: Float
  staff_id: Float
}

"""
columns and relationships of "sales_by_film_category"
"""
type sales_by_film_category {
  category: String
  total_sales: numeric
}

"""
aggregated selection of "sales_by_film_category"
"""
type sales_by_film_category_aggregate {
  aggregate: sales_by_film_category_aggregate_fields
  nodes: [sales_by_film_category!]!
}

"""
aggregate fields of "sales_by_film_category"
"""
type sales_by_film_category_aggregate_fields {
  avg: sales_by_film_category_avg_fields
  count(columns: [sales_by_film_category_select_column!], distinct: Boolean): Int!
  max: sales_by_film_category_max_fields
  min: sales_by_film_category_min_fields
  stddev: sales_by_film_category_stddev_fields
  stddev_pop: sales_by_film_category_stddev_pop_fields
  stddev_samp: sales_by_film_category_stddev_samp_fields
  sum: sales_by_film_category_sum_fields
  var_pop: sales_by_film_category_var_pop_fields
  var_samp: sales_by_film_category_var_samp_fields
  variance: sales_by_film_category_variance_fields
}

"""aggregate avg on columns"""
type sales_by_film_category_avg_fields {
  total_sales: Float
}

"""
Boolean expression to filter rows from the table "sales_by_film_category". All fields are combined with a logical 'AND'.
"""
input sales_by_film_category_bool_exp {
  _and: [sales_by_film_category_bool_exp!]
  _not: sales_by_film_category_bool_exp
  _or: [sales_by_film_category_bool_exp!]
  category: String_comparison_exp
  total_sales: numeric_comparison_exp
}

"""aggregate max on columns"""
type sales_by_film_category_max_fields {
  category: String
  total_sales: numeric
}

"""aggregate min on columns"""
type sales_by_film_category_min_fields {
  category: String
  total_sales: numeric
}

"""Ordering options when selecting data from "sales_by_film_category"."""
input sales_by_film_category_order_by {
  category: order_by
  total_sales: order_by
}

"""
select columns of table "sales_by_film_category"
"""
enum sales_by_film_category_select_column {
  """column name"""
  category

  """column name"""
  total_sales
}

"""aggregate stddev on columns"""
type sales_by_film_category_stddev_fields {
  total_sales: Float
}

"""aggregate stddev_pop on columns"""
type sales_by_film_category_stddev_pop_fields {
  total_sales: Float
}

"""aggregate stddev_samp on columns"""
type sales_by_film_category_stddev_samp_fields {
  total_sales: Float
}

"""aggregate sum on columns"""
type sales_by_film_category_sum_fields {
  total_sales: numeric
}

"""aggregate var_pop on columns"""
type sales_by_film_category_var_pop_fields {
  total_sales: Float
}

"""aggregate var_samp on columns"""
type sales_by_film_category_var_samp_fields {
  total_sales: Float
}

"""aggregate variance on columns"""
type sales_by_film_category_variance_fields {
  total_sales: Float
}

"""
columns and relationships of "sales_by_store"
"""
type sales_by_store {
  manager: String
  store: String
  total_sales: numeric
}

"""
aggregated selection of "sales_by_store"
"""
type sales_by_store_aggregate {
  aggregate: sales_by_store_aggregate_fields
  nodes: [sales_by_store!]!
}

"""
aggregate fields of "sales_by_store"
"""
type sales_by_store_aggregate_fields {
  avg: sales_by_store_avg_fields
  count(columns: [sales_by_store_select_column!], distinct: Boolean): Int!
  max: sales_by_store_max_fields
  min: sales_by_store_min_fields
  stddev: sales_by_store_stddev_fields
  stddev_pop: sales_by_store_stddev_pop_fields
  stddev_samp: sales_by_store_stddev_samp_fields
  sum: sales_by_store_sum_fields
  var_pop: sales_by_store_var_pop_fields
  var_samp: sales_by_store_var_samp_fields
  variance: sales_by_store_variance_fields
}

"""aggregate avg on columns"""
type sales_by_store_avg_fields {
  total_sales: Float
}

"""
Boolean expression to filter rows from the table "sales_by_store". All fields are combined with a logical 'AND'.
"""
input sales_by_store_bool_exp {
  _and: [sales_by_store_bool_exp!]
  _not: sales_by_store_bool_exp
  _or: [sales_by_store_bool_exp!]
  manager: String_comparison_exp
  store: String_comparison_exp
  total_sales: numeric_comparison_exp
}

"""aggregate max on columns"""
type sales_by_store_max_fields {
  manager: String
  store: String
  total_sales: numeric
}

"""aggregate min on columns"""
type sales_by_store_min_fields {
  manager: String
  store: String
  total_sales: numeric
}

"""Ordering options when selecting data from "sales_by_store"."""
input sales_by_store_order_by {
  manager: order_by
  store: order_by
  total_sales: order_by
}

"""
select columns of table "sales_by_store"
"""
enum sales_by_store_select_column {
  """column name"""
  manager

  """column name"""
  store

  """column name"""
  total_sales
}

"""aggregate stddev on columns"""
type sales_by_store_stddev_fields {
  total_sales: Float
}

"""aggregate stddev_pop on columns"""
type sales_by_store_stddev_pop_fields {
  total_sales: Float
}

"""aggregate stddev_samp on columns"""
type sales_by_store_stddev_samp_fields {
  total_sales: Float
}

"""aggregate sum on columns"""
type sales_by_store_sum_fields {
  total_sales: numeric
}

"""aggregate var_pop on columns"""
type sales_by_store_var_pop_fields {
  total_sales: Float
}

"""aggregate var_samp on columns"""
type sales_by_store_var_samp_fields {
  total_sales: Float
}

"""aggregate variance on columns"""
type sales_by_store_variance_fields {
  total_sales: Float
}

scalar smallint

"""
Boolean expression to compare columns of type "smallint". All fields are combined with logical 'AND'.
"""
input smallint_comparison_exp {
  _eq: smallint
  _gt: smallint
  _gte: smallint
  _in: [smallint!]
  _is_null: Boolean
  _lt: smallint
  _lte: smallint
  _neq: smallint
  _nin: [smallint!]
}

"""
columns and relationships of "staff"
"""
type staff {
  active: Boolean!
  address_id: smallint!
  email: String
  first_name: String!
  last_name: String!
  last_update: timestamp!
  password: String
  picture: bytea
  staff_id: Int!
  store_id: smallint!
  username: String!
}

"""
aggregated selection of "staff"
"""
type staff_aggregate {
  aggregate: staff_aggregate_fields
  nodes: [staff!]!
}

"""
aggregate fields of "staff"
"""
type staff_aggregate_fields {
  avg: staff_avg_fields
  count(columns: [staff_select_column!], distinct: Boolean): Int!
  max: staff_max_fields
  min: staff_min_fields
  stddev: staff_stddev_fields
  stddev_pop: staff_stddev_pop_fields
  stddev_samp: staff_stddev_samp_fields
  sum: staff_sum_fields
  var_pop: staff_var_pop_fields
  var_samp: staff_var_samp_fields
  variance: staff_variance_fields
}

"""aggregate avg on columns"""
type staff_avg_fields {
  address_id: Float
  staff_id: Float
  store_id: Float
}

"""
Boolean expression to filter rows from the table "staff". All fields are combined with a logical 'AND'.
"""
input staff_bool_exp {
  _and: [staff_bool_exp!]
  _not: staff_bool_exp
  _or: [staff_bool_exp!]
  active: Boolean_comparison_exp
  address_id: smallint_comparison_exp
  email: String_comparison_exp
  first_name: String_comparison_exp
  last_name: String_comparison_exp
  last_update: timestamp_comparison_exp
  password: String_comparison_exp
  picture: bytea_comparison_exp
  staff_id: Int_comparison_exp
  store_id: smallint_comparison_exp
  username: String_comparison_exp
}

"""
unique or primary key constraints on table "staff"
"""
enum staff_constraint {
  """unique or primary key constraint"""
  staff_pkey
}

"""
input type for incrementing numeric columns in table "staff"
"""
input staff_inc_input {
  address_id: smallint
  staff_id: Int
  store_id: smallint
}

"""
input type for inserting data into table "staff"
"""
input staff_insert_input {
  active: Boolean
  address_id: smallint
  email: String
  first_name: String
  last_name: String
  last_update: timestamp
  password: String
  picture: bytea
  staff_id: Int
  store_id: smallint
  username: String
}

"""
columns and relationships of "staff_list"
"""
type staff_list {
  address: String
  city: String
  country: String
  id: Int
  name: String
  phone: String
  sid: smallint
  zip_code: String
}

"""
aggregated selection of "staff_list"
"""
type staff_list_aggregate {
  aggregate: staff_list_aggregate_fields
  nodes: [staff_list!]!
}

"""
aggregate fields of "staff_list"
"""
type staff_list_aggregate_fields {
  avg: staff_list_avg_fields
  count(columns: [staff_list_select_column!], distinct: Boolean): Int!
  max: staff_list_max_fields
  min: staff_list_min_fields
  stddev: staff_list_stddev_fields
  stddev_pop: staff_list_stddev_pop_fields
  stddev_samp: staff_list_stddev_samp_fields
  sum: staff_list_sum_fields
  var_pop: staff_list_var_pop_fields
  var_samp: staff_list_var_samp_fields
  variance: staff_list_variance_fields
}

"""aggregate avg on columns"""
type staff_list_avg_fields {
  id: Float
  sid: Float
}

"""
Boolean expression to filter rows from the table "staff_list". All fields are combined with a logical 'AND'.
"""
input staff_list_bool_exp {
  _and: [staff_list_bool_exp!]
  _not: staff_list_bool_exp
  _or: [staff_list_bool_exp!]
  address: String_comparison_exp
  city: String_comparison_exp
  country: String_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  phone: String_comparison_exp
  sid: smallint_comparison_exp
  zip_code: String_comparison_exp
}

"""aggregate max on columns"""
type staff_list_max_fields {
  address: String
  city: String
  country: String
  id: Int
  name: String
  phone: String
  sid: smallint
  zip_code: String
}

"""aggregate min on columns"""
type staff_list_min_fields {
  address: String
  city: String
  country: String
  id: Int
  name: String
  phone: String
  sid: smallint
  zip_code: String
}

"""Ordering options when selecting data from "staff_list"."""
input staff_list_order_by {
  address: order_by
  city: order_by
  country: order_by
  id: order_by
  name: order_by
  phone: order_by
  sid: order_by
  zip_code: order_by
}

"""
select columns of table "staff_list"
"""
enum staff_list_select_column {
  """column name"""
  address

  """column name"""
  city

  """column name"""
  country

  """column name"""
  id

  """column name"""
  name

  """column name"""
  phone

  """column name"""
  sid

  """column name"""
  zip_code
}

"""aggregate stddev on columns"""
type staff_list_stddev_fields {
  id: Float
  sid: Float
}

"""aggregate stddev_pop on columns"""
type staff_list_stddev_pop_fields {
  id: Float
  sid: Float
}

"""aggregate stddev_samp on columns"""
type staff_list_stddev_samp_fields {
  id: Float
  sid: Float
}

"""aggregate sum on columns"""
type staff_list_sum_fields {
  id: Int
  sid: smallint
}

"""aggregate var_pop on columns"""
type staff_list_var_pop_fields {
  id: Float
  sid: Float
}

"""aggregate var_samp on columns"""
type staff_list_var_samp_fields {
  id: Float
  sid: Float
}

"""aggregate variance on columns"""
type staff_list_variance_fields {
  id: Float
  sid: Float
}

"""aggregate max on columns"""
type staff_max_fields {
  address_id: smallint
  email: String
  first_name: String
  last_name: String
  last_update: timestamp
  password: String
  staff_id: Int
  store_id: smallint
  username: String
}

"""aggregate min on columns"""
type staff_min_fields {
  address_id: smallint
  email: String
  first_name: String
  last_name: String
  last_update: timestamp
  password: String
  staff_id: Int
  store_id: smallint
  username: String
}

"""
response of any mutation on the table "staff"
"""
type staff_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [staff!]!
}

"""
on conflict condition type for table "staff"
"""
input staff_on_conflict {
  constraint: staff_constraint!
  update_columns: [staff_update_column!]! = []
  where: staff_bool_exp
}

"""Ordering options when selecting data from "staff"."""
input staff_order_by {
  active: order_by
  address_id: order_by
  email: order_by
  first_name: order_by
  last_name: order_by
  last_update: order_by
  password: order_by
  picture: order_by
  staff_id: order_by
  store_id: order_by
  username: order_by
}

"""primary key columns input for table: staff"""
input staff_pk_columns_input {
  staff_id: Int!
}

"""
select columns of table "staff"
"""
enum staff_select_column {
  """column name"""
  active

  """column name"""
  address_id

  """column name"""
  email

  """column name"""
  first_name

  """column name"""
  last_name

  """column name"""
  last_update

  """column name"""
  password

  """column name"""
  picture

  """column name"""
  staff_id

  """column name"""
  store_id

  """column name"""
  username
}

"""
input type for updating data in table "staff"
"""
input staff_set_input {
  active: Boolean
  address_id: smallint
  email: String
  first_name: String
  last_name: String
  last_update: timestamp
  password: String
  picture: bytea
  staff_id: Int
  store_id: smallint
  username: String
}

"""aggregate stddev on columns"""
type staff_stddev_fields {
  address_id: Float
  staff_id: Float
  store_id: Float
}

"""aggregate stddev_pop on columns"""
type staff_stddev_pop_fields {
  address_id: Float
  staff_id: Float
  store_id: Float
}

"""aggregate stddev_samp on columns"""
type staff_stddev_samp_fields {
  address_id: Float
  staff_id: Float
  store_id: Float
}

"""aggregate sum on columns"""
type staff_sum_fields {
  address_id: smallint
  staff_id: Int
  store_id: smallint
}

"""
update columns of table "staff"
"""
enum staff_update_column {
  """column name"""
  active

  """column name"""
  address_id

  """column name"""
  email

  """column name"""
  first_name

  """column name"""
  last_name

  """column name"""
  last_update

  """column name"""
  password

  """column name"""
  picture

  """column name"""
  staff_id

  """column name"""
  store_id

  """column name"""
  username
}

"""aggregate var_pop on columns"""
type staff_var_pop_fields {
  address_id: Float
  staff_id: Float
  store_id: Float
}

"""aggregate var_samp on columns"""
type staff_var_samp_fields {
  address_id: Float
  staff_id: Float
  store_id: Float
}

"""aggregate variance on columns"""
type staff_variance_fields {
  address_id: Float
  staff_id: Float
  store_id: Float
}

"""
columns and relationships of "store"
"""
type store {
  address_id: smallint!
  last_update: timestamp!
  manager_staff_id: smallint!
  store_id: Int!
}

"""
aggregated selection of "store"
"""
type store_aggregate {
  aggregate: store_aggregate_fields
  nodes: [store!]!
}

"""
aggregate fields of "store"
"""
type store_aggregate_fields {
  avg: store_avg_fields
  count(columns: [store_select_column!], distinct: Boolean): Int!
  max: store_max_fields
  min: store_min_fields
  stddev: store_stddev_fields
  stddev_pop: store_stddev_pop_fields
  stddev_samp: store_stddev_samp_fields
  sum: store_sum_fields
  var_pop: store_var_pop_fields
  var_samp: store_var_samp_fields
  variance: store_variance_fields
}

"""aggregate avg on columns"""
type store_avg_fields {
  address_id: Float
  manager_staff_id: Float
  store_id: Float
}

"""
Boolean expression to filter rows from the table "store". All fields are combined with a logical 'AND'.
"""
input store_bool_exp {
  _and: [store_bool_exp!]
  _not: store_bool_exp
  _or: [store_bool_exp!]
  address_id: smallint_comparison_exp
  last_update: timestamp_comparison_exp
  manager_staff_id: smallint_comparison_exp
  store_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "store"
"""
enum store_constraint {
  """unique or primary key constraint"""
  idx_unq_manager_staff_id

  """unique or primary key constraint"""
  store_pkey
}

"""
input type for incrementing numeric columns in table "store"
"""
input store_inc_input {
  address_id: smallint
  manager_staff_id: smallint
  store_id: Int
}

"""
input type for inserting data into table "store"
"""
input store_insert_input {
  address_id: smallint
  last_update: timestamp
  manager_staff_id: smallint
  store_id: Int
}

"""aggregate max on columns"""
type store_max_fields {
  address_id: smallint
  last_update: timestamp
  manager_staff_id: smallint
  store_id: Int
}

"""aggregate min on columns"""
type store_min_fields {
  address_id: smallint
  last_update: timestamp
  manager_staff_id: smallint
  store_id: Int
}

"""
response of any mutation on the table "store"
"""
type store_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [store!]!
}

"""
on conflict condition type for table "store"
"""
input store_on_conflict {
  constraint: store_constraint!
  update_columns: [store_update_column!]! = []
  where: store_bool_exp
}

"""Ordering options when selecting data from "store"."""
input store_order_by {
  address_id: order_by
  last_update: order_by
  manager_staff_id: order_by
  store_id: order_by
}

"""primary key columns input for table: store"""
input store_pk_columns_input {
  store_id: Int!
}

"""
select columns of table "store"
"""
enum store_select_column {
  """column name"""
  address_id

  """column name"""
  last_update

  """column name"""
  manager_staff_id

  """column name"""
  store_id
}

"""
input type for updating data in table "store"
"""
input store_set_input {
  address_id: smallint
  last_update: timestamp
  manager_staff_id: smallint
  store_id: Int
}

"""aggregate stddev on columns"""
type store_stddev_fields {
  address_id: Float
  manager_staff_id: Float
  store_id: Float
}

"""aggregate stddev_pop on columns"""
type store_stddev_pop_fields {
  address_id: Float
  manager_staff_id: Float
  store_id: Float
}

"""aggregate stddev_samp on columns"""
type store_stddev_samp_fields {
  address_id: Float
  manager_staff_id: Float
  store_id: Float
}

"""aggregate sum on columns"""
type store_sum_fields {
  address_id: smallint
  manager_staff_id: smallint
  store_id: Int
}

"""
update columns of table "store"
"""
enum store_update_column {
  """column name"""
  address_id

  """column name"""
  last_update

  """column name"""
  manager_staff_id

  """column name"""
  store_id
}

"""aggregate var_pop on columns"""
type store_var_pop_fields {
  address_id: Float
  manager_staff_id: Float
  store_id: Float
}

"""aggregate var_samp on columns"""
type store_var_samp_fields {
  address_id: Float
  manager_staff_id: Float
  store_id: Float
}

"""aggregate variance on columns"""
type store_variance_fields {
  address_id: Float
  manager_staff_id: Float
  store_id: Float
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

type subscription_root {
  """
  fetch data from the table: "actor"
  """
  actor(
    """distinct select on columns"""
    distinct_on: [actor_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [actor_order_by!]

    """filter the rows returned"""
    where: actor_bool_exp
  ): [actor!]!

  """
  fetch aggregated fields from the table: "actor"
  """
  actor_aggregate(
    """distinct select on columns"""
    distinct_on: [actor_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [actor_order_by!]

    """filter the rows returned"""
    where: actor_bool_exp
  ): actor_aggregate!

  """fetch data from the table: "actor" using primary key columns"""
  actor_by_pk(actor_id: Int!): actor

  """
  fetch data from the table: "actor_info"
  """
  actor_info(
    """distinct select on columns"""
    distinct_on: [actor_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [actor_info_order_by!]

    """filter the rows returned"""
    where: actor_info_bool_exp
  ): [actor_info!]!

  """
  fetch aggregated fields from the table: "actor_info"
  """
  actor_info_aggregate(
    """distinct select on columns"""
    distinct_on: [actor_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [actor_info_order_by!]

    """filter the rows returned"""
    where: actor_info_bool_exp
  ): actor_info_aggregate!

  """
  fetch data from the table: "address"
  """
  address(
    """distinct select on columns"""
    distinct_on: [address_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [address_order_by!]

    """filter the rows returned"""
    where: address_bool_exp
  ): [address!]!

  """
  fetch aggregated fields from the table: "address"
  """
  address_aggregate(
    """distinct select on columns"""
    distinct_on: [address_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [address_order_by!]

    """filter the rows returned"""
    where: address_bool_exp
  ): address_aggregate!

  """fetch data from the table: "address" using primary key columns"""
  address_by_pk(address_id: Int!): address

  """
  fetch data from the table: "category"
  """
  category(
    """distinct select on columns"""
    distinct_on: [category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [category_order_by!]

    """filter the rows returned"""
    where: category_bool_exp
  ): [category!]!

  """
  fetch aggregated fields from the table: "category"
  """
  category_aggregate(
    """distinct select on columns"""
    distinct_on: [category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [category_order_by!]

    """filter the rows returned"""
    where: category_bool_exp
  ): category_aggregate!

  """fetch data from the table: "category" using primary key columns"""
  category_by_pk(category_id: Int!): category

  """
  fetch data from the table: "city"
  """
  city(
    """distinct select on columns"""
    distinct_on: [city_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [city_order_by!]

    """filter the rows returned"""
    where: city_bool_exp
  ): [city!]!

  """
  fetch aggregated fields from the table: "city"
  """
  city_aggregate(
    """distinct select on columns"""
    distinct_on: [city_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [city_order_by!]

    """filter the rows returned"""
    where: city_bool_exp
  ): city_aggregate!

  """fetch data from the table: "city" using primary key columns"""
  city_by_pk(city_id: Int!): city

  """
  fetch data from the table: "country"
  """
  country(
    """distinct select on columns"""
    distinct_on: [country_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [country_order_by!]

    """filter the rows returned"""
    where: country_bool_exp
  ): [country!]!

  """
  fetch aggregated fields from the table: "country"
  """
  country_aggregate(
    """distinct select on columns"""
    distinct_on: [country_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [country_order_by!]

    """filter the rows returned"""
    where: country_bool_exp
  ): country_aggregate!

  """fetch data from the table: "country" using primary key columns"""
  country_by_pk(country_id: Int!): country

  """
  fetch data from the table: "customer"
  """
  customer(
    """distinct select on columns"""
    distinct_on: [customer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_order_by!]

    """filter the rows returned"""
    where: customer_bool_exp
  ): [customer!]!

  """
  fetch aggregated fields from the table: "customer"
  """
  customer_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_order_by!]

    """filter the rows returned"""
    where: customer_bool_exp
  ): customer_aggregate!

  """fetch data from the table: "customer" using primary key columns"""
  customer_by_pk(customer_id: Int!): customer

  """
  fetch data from the table: "customer_list"
  """
  customer_list(
    """distinct select on columns"""
    distinct_on: [customer_list_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_list_order_by!]

    """filter the rows returned"""
    where: customer_list_bool_exp
  ): [customer_list!]!

  """
  fetch aggregated fields from the table: "customer_list"
  """
  customer_list_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_list_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_list_order_by!]

    """filter the rows returned"""
    where: customer_list_bool_exp
  ): customer_list_aggregate!

  """
  fetch data from the table: "film"
  """
  film(
    """distinct select on columns"""
    distinct_on: [film_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [film_order_by!]

    """filter the rows returned"""
    where: film_bool_exp
  ): [film!]!

  """
  fetch data from the table: "film_actor"
  """
  film_actor(
    """distinct select on columns"""
    distinct_on: [film_actor_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [film_actor_order_by!]

    """filter the rows returned"""
    where: film_actor_bool_exp
  ): [film_actor!]!

  """
  fetch aggregated fields from the table: "film_actor"
  """
  film_actor_aggregate(
    """distinct select on columns"""
    distinct_on: [film_actor_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [film_actor_order_by!]

    """filter the rows returned"""
    where: film_actor_bool_exp
  ): film_actor_aggregate!

  """fetch data from the table: "film_actor" using primary key columns"""
  film_actor_by_pk(actor_id: smallint!, film_id: smallint!): film_actor

  """
  fetch aggregated fields from the table: "film"
  """
  film_aggregate(
    """distinct select on columns"""
    distinct_on: [film_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [film_order_by!]

    """filter the rows returned"""
    where: film_bool_exp
  ): film_aggregate!

  """fetch data from the table: "film" using primary key columns"""
  film_by_pk(film_id: Int!): film

  """
  fetch data from the table: "film_category"
  """
  film_category(
    """distinct select on columns"""
    distinct_on: [film_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [film_category_order_by!]

    """filter the rows returned"""
    where: film_category_bool_exp
  ): [film_category!]!

  """
  fetch aggregated fields from the table: "film_category"
  """
  film_category_aggregate(
    """distinct select on columns"""
    distinct_on: [film_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [film_category_order_by!]

    """filter the rows returned"""
    where: film_category_bool_exp
  ): film_category_aggregate!

  """fetch data from the table: "film_category" using primary key columns"""
  film_category_by_pk(category_id: smallint!, film_id: smallint!): film_category

  """
  fetch data from the table: "film_list"
  """
  film_list(
    """distinct select on columns"""
    distinct_on: [film_list_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [film_list_order_by!]

    """filter the rows returned"""
    where: film_list_bool_exp
  ): [film_list!]!

  """
  fetch aggregated fields from the table: "film_list"
  """
  film_list_aggregate(
    """distinct select on columns"""
    distinct_on: [film_list_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [film_list_order_by!]

    """filter the rows returned"""
    where: film_list_bool_exp
  ): film_list_aggregate!

  """
  fetch data from the table: "inventory"
  """
  inventory(
    """distinct select on columns"""
    distinct_on: [inventory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [inventory_order_by!]

    """filter the rows returned"""
    where: inventory_bool_exp
  ): [inventory!]!

  """
  fetch aggregated fields from the table: "inventory"
  """
  inventory_aggregate(
    """distinct select on columns"""
    distinct_on: [inventory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [inventory_order_by!]

    """filter the rows returned"""
    where: inventory_bool_exp
  ): inventory_aggregate!

  """fetch data from the table: "inventory" using primary key columns"""
  inventory_by_pk(inventory_id: Int!): inventory

  """
  fetch data from the table: "language"
  """
  language(
    """distinct select on columns"""
    distinct_on: [language_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [language_order_by!]

    """filter the rows returned"""
    where: language_bool_exp
  ): [language!]!

  """
  fetch aggregated fields from the table: "language"
  """
  language_aggregate(
    """distinct select on columns"""
    distinct_on: [language_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [language_order_by!]

    """filter the rows returned"""
    where: language_bool_exp
  ): language_aggregate!

  """fetch data from the table: "language" using primary key columns"""
  language_by_pk(language_id: Int!): language

  """
  fetch data from the table: "nicer_but_slower_film_list"
  """
  nicer_but_slower_film_list(
    """distinct select on columns"""
    distinct_on: [nicer_but_slower_film_list_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [nicer_but_slower_film_list_order_by!]

    """filter the rows returned"""
    where: nicer_but_slower_film_list_bool_exp
  ): [nicer_but_slower_film_list!]!

  """
  fetch aggregated fields from the table: "nicer_but_slower_film_list"
  """
  nicer_but_slower_film_list_aggregate(
    """distinct select on columns"""
    distinct_on: [nicer_but_slower_film_list_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [nicer_but_slower_film_list_order_by!]

    """filter the rows returned"""
    where: nicer_but_slower_film_list_bool_exp
  ): nicer_but_slower_film_list_aggregate!

  """
  fetch data from the table: "payment"
  """
  payment(
    """distinct select on columns"""
    distinct_on: [payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_order_by!]

    """filter the rows returned"""
    where: payment_bool_exp
  ): [payment!]!

  """
  fetch aggregated fields from the table: "payment"
  """
  payment_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_order_by!]

    """filter the rows returned"""
    where: payment_bool_exp
  ): payment_aggregate!

  """fetch data from the table: "payment" using primary key columns"""
  payment_by_pk(payment_id: Int!): payment

  """
  fetch data from the table: "payment_p2007_01"
  """
  payment_p2007_01(
    """distinct select on columns"""
    distinct_on: [payment_p2007_01_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_p2007_01_order_by!]

    """filter the rows returned"""
    where: payment_p2007_01_bool_exp
  ): [payment_p2007_01!]!

  """
  fetch aggregated fields from the table: "payment_p2007_01"
  """
  payment_p2007_01_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_p2007_01_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_p2007_01_order_by!]

    """filter the rows returned"""
    where: payment_p2007_01_bool_exp
  ): payment_p2007_01_aggregate!

  """
  fetch data from the table: "payment_p2007_02"
  """
  payment_p2007_02(
    """distinct select on columns"""
    distinct_on: [payment_p2007_02_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_p2007_02_order_by!]

    """filter the rows returned"""
    where: payment_p2007_02_bool_exp
  ): [payment_p2007_02!]!

  """
  fetch aggregated fields from the table: "payment_p2007_02"
  """
  payment_p2007_02_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_p2007_02_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_p2007_02_order_by!]

    """filter the rows returned"""
    where: payment_p2007_02_bool_exp
  ): payment_p2007_02_aggregate!

  """
  fetch data from the table: "payment_p2007_03"
  """
  payment_p2007_03(
    """distinct select on columns"""
    distinct_on: [payment_p2007_03_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_p2007_03_order_by!]

    """filter the rows returned"""
    where: payment_p2007_03_bool_exp
  ): [payment_p2007_03!]!

  """
  fetch aggregated fields from the table: "payment_p2007_03"
  """
  payment_p2007_03_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_p2007_03_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_p2007_03_order_by!]

    """filter the rows returned"""
    where: payment_p2007_03_bool_exp
  ): payment_p2007_03_aggregate!

  """
  fetch data from the table: "payment_p2007_04"
  """
  payment_p2007_04(
    """distinct select on columns"""
    distinct_on: [payment_p2007_04_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_p2007_04_order_by!]

    """filter the rows returned"""
    where: payment_p2007_04_bool_exp
  ): [payment_p2007_04!]!

  """
  fetch aggregated fields from the table: "payment_p2007_04"
  """
  payment_p2007_04_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_p2007_04_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_p2007_04_order_by!]

    """filter the rows returned"""
    where: payment_p2007_04_bool_exp
  ): payment_p2007_04_aggregate!

  """
  fetch data from the table: "payment_p2007_05"
  """
  payment_p2007_05(
    """distinct select on columns"""
    distinct_on: [payment_p2007_05_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_p2007_05_order_by!]

    """filter the rows returned"""
    where: payment_p2007_05_bool_exp
  ): [payment_p2007_05!]!

  """
  fetch aggregated fields from the table: "payment_p2007_05"
  """
  payment_p2007_05_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_p2007_05_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_p2007_05_order_by!]

    """filter the rows returned"""
    where: payment_p2007_05_bool_exp
  ): payment_p2007_05_aggregate!

  """
  fetch data from the table: "payment_p2007_06"
  """
  payment_p2007_06(
    """distinct select on columns"""
    distinct_on: [payment_p2007_06_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_p2007_06_order_by!]

    """filter the rows returned"""
    where: payment_p2007_06_bool_exp
  ): [payment_p2007_06!]!

  """
  fetch aggregated fields from the table: "payment_p2007_06"
  """
  payment_p2007_06_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_p2007_06_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_p2007_06_order_by!]

    """filter the rows returned"""
    where: payment_p2007_06_bool_exp
  ): payment_p2007_06_aggregate!

  """
  fetch data from the table: "rental"
  """
  rental(
    """distinct select on columns"""
    distinct_on: [rental_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rental_order_by!]

    """filter the rows returned"""
    where: rental_bool_exp
  ): [rental!]!

  """
  fetch aggregated fields from the table: "rental"
  """
  rental_aggregate(
    """distinct select on columns"""
    distinct_on: [rental_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rental_order_by!]

    """filter the rows returned"""
    where: rental_bool_exp
  ): rental_aggregate!

  """fetch data from the table: "rental" using primary key columns"""
  rental_by_pk(rental_id: Int!): rental

  """
  fetch data from the table: "sales_by_film_category"
  """
  sales_by_film_category(
    """distinct select on columns"""
    distinct_on: [sales_by_film_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sales_by_film_category_order_by!]

    """filter the rows returned"""
    where: sales_by_film_category_bool_exp
  ): [sales_by_film_category!]!

  """
  fetch aggregated fields from the table: "sales_by_film_category"
  """
  sales_by_film_category_aggregate(
    """distinct select on columns"""
    distinct_on: [sales_by_film_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sales_by_film_category_order_by!]

    """filter the rows returned"""
    where: sales_by_film_category_bool_exp
  ): sales_by_film_category_aggregate!

  """
  fetch data from the table: "sales_by_store"
  """
  sales_by_store(
    """distinct select on columns"""
    distinct_on: [sales_by_store_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sales_by_store_order_by!]

    """filter the rows returned"""
    where: sales_by_store_bool_exp
  ): [sales_by_store!]!

  """
  fetch aggregated fields from the table: "sales_by_store"
  """
  sales_by_store_aggregate(
    """distinct select on columns"""
    distinct_on: [sales_by_store_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sales_by_store_order_by!]

    """filter the rows returned"""
    where: sales_by_store_bool_exp
  ): sales_by_store_aggregate!

  """
  fetch data from the table: "staff"
  """
  staff(
    """distinct select on columns"""
    distinct_on: [staff_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [staff_order_by!]

    """filter the rows returned"""
    where: staff_bool_exp
  ): [staff!]!

  """
  fetch aggregated fields from the table: "staff"
  """
  staff_aggregate(
    """distinct select on columns"""
    distinct_on: [staff_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [staff_order_by!]

    """filter the rows returned"""
    where: staff_bool_exp
  ): staff_aggregate!

  """fetch data from the table: "staff" using primary key columns"""
  staff_by_pk(staff_id: Int!): staff

  """
  fetch data from the table: "staff_list"
  """
  staff_list(
    """distinct select on columns"""
    distinct_on: [staff_list_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [staff_list_order_by!]

    """filter the rows returned"""
    where: staff_list_bool_exp
  ): [staff_list!]!

  """
  fetch aggregated fields from the table: "staff_list"
  """
  staff_list_aggregate(
    """distinct select on columns"""
    distinct_on: [staff_list_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [staff_list_order_by!]

    """filter the rows returned"""
    where: staff_list_bool_exp
  ): staff_list_aggregate!

  """
  fetch data from the table: "store"
  """
  store(
    """distinct select on columns"""
    distinct_on: [store_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [store_order_by!]

    """filter the rows returned"""
    where: store_bool_exp
  ): [store!]!

  """
  fetch aggregated fields from the table: "store"
  """
  store_aggregate(
    """distinct select on columns"""
    distinct_on: [store_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [store_order_by!]

    """filter the rows returned"""
    where: store_bool_exp
  ): store_aggregate!

  """fetch data from the table: "store" using primary key columns"""
  store_by_pk(store_id: Int!): store
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

scalar tsvector

"""
Boolean expression to compare columns of type "tsvector". All fields are combined with logical 'AND'.
"""
input tsvector_comparison_exp {
  _eq: tsvector
  _gt: tsvector
  _gte: tsvector
  _in: [tsvector!]
  _is_null: Boolean
  _lt: tsvector
  _lte: tsvector
  _neq: tsvector
  _nin: [tsvector!]
}

